<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.0">Jekyll</generator><link href="http://localhost:4000/blog/blog_tech/_site/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/blog/blog_tech/_site/" rel="alternate" type="text/html" /><updated>2017-07-29T13:47:10+09:00</updated><id>http://localhost:4000/blog/blog_tech/_site/</id><title type="html">candy water’s tech blog</title><subtitle>this is candy water's technology blog
</subtitle><entry><title type="html">探索服务器里有趣的log(1)</title><link href="http://localhost:4000/blog/blog_tech/_site/2017/07/23/about_log_1.html" rel="alternate" type="text/html" title="探索服务器里有趣的log(1)" /><published>2017-07-23T00:00:00+09:00</published><updated>2017-07-23T00:00:00+09:00</updated><id>http://localhost:4000/blog/blog_tech/_site/2017/07/23/about_log_1</id><content type="html" xml:base="http://localhost:4000/blog/blog_tech/_site/2017/07/23/about_log_1.html">&lt;p&gt;计划涉及的部分&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;search engine robot (crawler)&lt;/li&gt;
  &lt;li&gt;w00tw00t group&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;写在最前&quot;&gt;写在最前&lt;/h2&gt;
&lt;p&gt;本篇计划写第一部分 – crawler的部分.
不过因为多少是按照心情去写,所以可能会影响篇幅.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;辅助工具&amp;amp;操作手法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;利用go-access (command-line)
将&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/apache2/&lt;/code&gt;里面的东西拿过来
然后逐个观察,发现奇妙事物.
是以2017July09起2017July23 02:59 +0900这个时点为止的所有log为样本进行强势围观.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;目前环境&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;apache2, ubuntu&lt;/p&gt;

&lt;h2 id=&quot;1&quot;&gt;1&lt;/h2&gt;
&lt;p&gt;首先,我发现的神奇的一点就是,
所有的log都是用这个名字来命名的.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;other_vhosts_access.log.[n]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;后面的[n]可以替换为任意的连续的阿拉伯数字.
神奇的一点在于,数字越小的越接近现在,数字越大的文件越老.
也就是说,
比如我现在生成了一个log,把他堆砌进入&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;other_vhosts_access.log.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;里面.&lt;/p&gt;

&lt;p&gt;那么我需要新生成一个全新的log文件的时候,就要把上一个&lt;code class=&quot;highlighter-rouge&quot;&gt;other_vhosts_access.log.1&lt;/code&gt;
改名变成&lt;code class=&quot;highlighter-rouge&quot;&gt;other_vhosts_access.log.2&lt;/code&gt;
然后再新生成一个全新的&lt;code class=&quot;highlighter-rouge&quot;&gt;other_vhosts_access.log.1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;一个两个文件还好.如果是20个文件,30个文件呢,就是要逐个改名的意思啊!!!!!!
我的天.真不知道他的内部是如何实现的这一功能的.&lt;/p&gt;

&lt;p&gt;那么我首先要做的,就是把这些文件全部拼接到一起…..
为了方便go-access进行数据集合访问啊!!&lt;/p&gt;

&lt;p&gt;好的,那么我们开始了!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 因为只有4行,我没用script
%cat other_vhosts_access.log.4 &amp;gt;&amp;gt; other_vhosts_access.log
%cat other_vhosts_access.log.3 &amp;gt;&amp;gt; other_vhosts_access.log
%cat other_vhosts_access.log.2 &amp;gt;&amp;gt; other_vhosts_access.log
%cat other_vhosts_access.log.1 &amp;gt;&amp;gt; other_vhosts_access.log
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;2-go-access&quot;&gt;2 go-access&lt;/h2&gt;

&lt;p&gt;go-access使用广泛,可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get&lt;/code&gt;直接安装.
PS:注意,在tmux种使用go-access时需要注意,因为tmux的默认设置是不允许使用tab的,
所以在go-access中没有办法去切换到数字是2位数以上的项目&lt;/p&gt;

&lt;p&gt;这里是我使用的log的format&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LogFormat &quot;%v:%p %h %l %u %t \&quot;%r\&quot; %&amp;gt;s %O \&quot;%{Referer}i\&quot; \&quot;%{User-Agent}i\&quot;&quot; vhost_combined
LogFormat &quot;%v:%p %h %l %u %t \&quot;%r\&quot; %&amp;gt;s %O \&quot;%{Referer}i\&quot; \&quot;%{User-Agent}i\&quot;&quot; combined
LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&amp;gt;s %O&quot; common
LogFormat &quot;%{Referer}i -&amp;gt; %U&quot; referer
LogFormat &quot;%{User-agent}i&quot; agent
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;crawler&quot;&gt;crawler&lt;/h2&gt;</content><author><name></name></author><category term="log, server, apache" /><summary type="html">计划涉及的部分 search engine robot (crawler) w00tw00t group 写在最前 本篇计划写第一部分 – crawler的部分. 不过因为多少是按照心情去写,所以可能会影响篇幅. 辅助工具&amp;amp;操作手法 利用go-access (command-line) 将/var/log/apache2/里面的东西拿过来 然后逐个观察,发现奇妙事物. 是以2017July09起2017July23 02:59 +0900这个时点为止的所有log为样本进行强势围观. 目前环境 apache2, ubuntu 1 首先,我发现的神奇的一点就是, 所有的log都是用这个名字来命名的. other_vhosts_access.log.[n] 后面的[n]可以替换为任意的连续的阿拉伯数字. 神奇的一点在于,数字越小的越接近现在,数字越大的文件越老. 也就是说, 比如我现在生成了一个log,把他堆砌进入 other_vhosts_access.log.1 里面. 那么我需要新生成一个全新的log文件的时候,就要把上一个other_vhosts_access.log.1 改名变成other_vhosts_access.log.2 然后再新生成一个全新的other_vhosts_access.log.1 一个两个文件还好.如果是20个文件,30个文件呢,就是要逐个改名的意思啊!!!!!! 我的天.真不知道他的内部是如何实现的这一功能的. 那么我首先要做的,就是把这些文件全部拼接到一起….. 为了方便go-access进行数据集合访问啊!! 好的,那么我们开始了! # 因为只有4行,我没用script %cat other_vhosts_access.log.4 &amp;gt;&amp;gt; other_vhosts_access.log %cat other_vhosts_access.log.3 &amp;gt;&amp;gt; other_vhosts_access.log %cat other_vhosts_access.log.2 &amp;gt;&amp;gt; other_vhosts_access.log %cat other_vhosts_access.log.1 &amp;gt;&amp;gt; other_vhosts_access.log 2 go-access go-access使用广泛,可以用apt-get直接安装. PS:注意,在tmux种使用go-access时需要注意,因为tmux的默认设置是不允许使用tab的, 所以在go-access中没有办法去切换到数字是2位数以上的项目 这里是我使用的log的format LogFormat &quot;%v:%p %h %l %u %t \&quot;%r\&quot; %&amp;gt;s %O \&quot;%{Referer}i\&quot; \&quot;%{User-Agent}i\&quot;&quot; vhost_combined LogFormat &quot;%v:%p %h %l %u %t \&quot;%r\&quot; %&amp;gt;s %O \&quot;%{Referer}i\&quot; \&quot;%{User-Agent}i\&quot;&quot; combined LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&amp;gt;s %O&quot; common LogFormat &quot;%{Referer}i -&amp;gt; %U&quot; referer LogFormat &quot;%{User-agent}i&quot; agent crawler</summary></entry><entry><title type="html">关于JAVA同期的初步学习(1)</title><link href="http://localhost:4000/blog/blog_tech/_site/2017/07/13/tech-java-sync.html" rel="alternate" type="text/html" title="关于JAVA同期的初步学习(1)" /><published>2017-07-13T00:00:00+09:00</published><updated>2017-07-13T00:00:00+09:00</updated><id>http://localhost:4000/blog/blog_tech/_site/2017/07/13/tech-java-sync</id><content type="html" xml:base="http://localhost:4000/blog/blog_tech/_site/2017/07/13/tech-java-sync.html">&lt;p&gt;缘由是看知乎的一个&lt;a href=&quot;https://zhihu.com/question/29971746/answer/46320214&quot;&gt;答案&lt;/a&gt;,
里面写到同期的部分愣是没看懂.
由于我自己也没写过需要同期的东西.
就参照几个东西边看边研究.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.techscore.com/tech/Java/JavaSE/Thread/index/&quot;&gt;techscore マルチスレッドプログラミング&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/jp/java/library/j-jtp06197.html&quot;&gt;IBM doc Javaの理論と実践: volatile を扱う&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html&quot;&gt;oracle doc Synchronized Methods&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://d.hatena.ne.jp/Nagise/20111130/1322628285&quot;&gt;Threadの割り込みを活用する&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;关于sleep&quot;&gt;关于sleep()&lt;/h3&gt;

&lt;p&gt;首先是关于sleep(),根本就没搞清楚他是什么意思.
(完全没有搞懂它内部是如何实现的)
自己动手丰衣足食,自己来尝试一下吧.&lt;/p&gt;

&lt;p&gt;假设有A,B两个class.
同时call(1 step的时间差忽略不计)
因为sleep是static method.
那么我想知道,&lt;/p&gt;

&lt;p&gt;如果class A每2秒count一次,
class B每3秒count一次.&lt;/p&gt;

&lt;p&gt;那么是否会出现,&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;time(s)&lt;/th&gt;
      &lt;th&gt;output A&lt;/th&gt;
      &lt;th&gt;output B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;的情况.( “-“ 代表不输出数值)&lt;/p&gt;

&lt;h4 id=&quot;代码如下&quot;&gt;代码如下&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Main.java&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main{

  public static void main(String args[]){
  TestThread a = new TestThread(&quot;class a&quot;, 2000);
  TestThread b = new TestThread(&quot;class b&quot;, 3000);

  a.start();
  b.start();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;TestThread.java&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
public class TestThread extends Thread {

  private String name;
  private long sleepTime;
  private long time;

  public TestThread (String name, long sleepTime){
    this.name = name;
    assert(sleepTime &amp;gt;= 0);
    this.sleepTime = sleepTime;
  }

  public void run(){
    this.time = System.currentTimeMillis();
    for (int i = 0; i &amp;lt; 3; ++i){
      try{
        sleep(sleepTime);
      }
      catch (InterruptedException e){
      }
      System.out.println(name + &quot; : &quot; + i +
        (System.currentTimeMillis() - time)/1000 + &quot;[s]&quot;);
    }
  }
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;结果-测试环境wsl-win10-openjdk-8&quot;&gt;&lt;strong&gt;结果&lt;/strong&gt; (测试环境WSL, win10, openjdk-8)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%time java Main
class a : 02[s]
class b : 03[s]
class a : 14[s]
class b : 16[s]
class a : 26[s]
class b : 29[s]
java Main 0.11s user 0.22s system 3% cpu 9.315 total
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以说是出现了匪夷所思的结果.
因为只运行了9秒,但是currentTimeMillis()却显示运行了近30秒.&lt;/p&gt;

&lt;p&gt;虽然显示的数值并不符合预期,
但事实上在class A的第三次,class B的第二次输出,几乎是同步进行的.
(对for文的数值更改为6,并进行的多次测试,获得同样结果)
&lt;strong&gt;符合我的猜测&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;解决了sleep()的疑问,但是带来了&lt;strong&gt;新的问题&lt;/strong&gt;.
这里的currentTimeMillis()到底是怎样的机制?
如何才能正确的测量时间?&lt;/p&gt;

&lt;p&gt;下个探索的阅读材料集锦&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://d.hatena.ne.jp/sardine/20091226/p1&quot;&gt;Java: currentTimeMillis() と nanoTime() は混ぜると危険&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://d.hatena.ne.jp/higher_tomorrow/20100407/1270639866&quot;&gt;Javaアプリケーションのログの時刻がずれている&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="JAVA," /><category term="sync" /><summary type="html">缘由是看知乎的一个答案, 里面写到同期的部分愣是没看懂. 由于我自己也没写过需要同期的东西. 就参照几个东西边看边研究. techscore マルチスレッドプログラミング IBM doc Javaの理論と実践: volatile を扱う oracle doc Synchronized Methods Threadの割り込みを活用する 关于sleep() 首先是关于sleep(),根本就没搞清楚他是什么意思. (完全没有搞懂它内部是如何实现的) 自己动手丰衣足食,自己来尝试一下吧. 假设有A,B两个class. 同时call(1 step的时间差忽略不计) 因为sleep是static method. 那么我想知道, 如果class A每2秒count一次, class B每3秒count一次. 那么是否会出现, time(s) output A output B 0 - - 1 - - 2 1 - 3 - 1 4 2 - 5 - - 6 3 3 7 - - 的情况.( “-“ 代表不输出数值) 代码如下 Main.java public class Main{ public static void main(String args[]){ TestThread a = new TestThread(&quot;class a&quot;, 2000); TestThread b = new TestThread(&quot;class b&quot;, 3000); a.start(); b.start(); } } TestThread.java public class TestThread extends Thread { private String name; private long sleepTime; private long time; public TestThread (String name, long sleepTime){ this.name = name; assert(sleepTime &amp;gt;= 0); this.sleepTime = sleepTime; } public void run(){ this.time = System.currentTimeMillis(); for (int i = 0; i &amp;lt; 3; ++i){ try{ sleep(sleepTime); } catch (InterruptedException e){ } System.out.println(name + &quot; : &quot; + i + (System.currentTimeMillis() - time)/1000 + &quot;[s]&quot;); } } } 结果 (测试环境WSL, win10, openjdk-8) %time java Main class a : 02[s] class b : 03[s] class a : 14[s] class b : 16[s] class a : 26[s] class b : 29[s] java Main 0.11s user 0.22s system 3% cpu 9.315 total 可以说是出现了匪夷所思的结果. 因为只运行了9秒,但是currentTimeMillis()却显示运行了近30秒. 虽然显示的数值并不符合预期, 但事实上在class A的第三次,class B的第二次输出,几乎是同步进行的. (对for文的数值更改为6,并进行的多次测试,获得同样结果) 符合我的猜测. 解决了sleep()的疑问,但是带来了新的问题. 这里的currentTimeMillis()到底是怎样的机制? 如何才能正确的测量时间? 下个探索的阅读材料集锦 Java: currentTimeMillis() と nanoTime() は混ぜると危険 Javaアプリケーションのログの時刻がずれている</summary></entry></feed>