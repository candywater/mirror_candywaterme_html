<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/blog/" rel="alternate" type="text/html" /><updated>2018-03-20T23:25:51+09:00</updated><id>http://localhost:4000/blog/</id><title type="html">Candy Water</title><subtitle>Welcome to Candy Water's world!!</subtitle><entry><title type="html">我所敬佩的</title><link href="http://localhost:4000/blog/essay_blog/essay/2018/03/15/about-what-u-believe.html" rel="alternate" type="text/html" title="我所敬佩的" /><published>2018-03-15T00:00:00+09:00</published><updated>2018-03-15T00:00:00+09:00</updated><id>http://localhost:4000/blog/essay_blog/essay/2018/03/15/about-what-u-believe</id><content type="html" xml:base="http://localhost:4000/blog/essay_blog/essay/2018/03/15/about-what-u-believe.html">&lt;!--#### 耶和華見證人--&gt;

&lt;p&gt;所有的宗教团体中。我最敬佩的就是耶和华见证人。&lt;/p&gt;

&lt;p&gt;历史上的宗教如此之多。宗教团体也很多。
我很喜欢自然宗教。比较符合原始生存的，自然信仰。比如，认为一切皆有灵的北欧信仰。比如，爱斯基摩对于杀戮之果的祭祀。再比如，亚洲大陆的萨满风俗（跳大神也是一种分支）。
他们迷信，但是无害。
不过自然信仰之所以抵挡不过后来的三大宗教，一个很大的原因就是没有一个强大的组织。他们并不知晓组织和团队力量的强大。
&lt;!--无论是做什么事，建造帝国也好，创建大学也罢。团体的能力是如此的强大。--&gt;
基督教的团体我也见过很多。很多。
比如摩尔门教，比如耶和华见证人。&lt;/p&gt;

&lt;p&gt;耶和华见证人成立的时间不长，最初是一个教授创立的。
这个教派的教规很有趣。在有着通有的严于律己的教律同时，还有一条非常有趣的律己教律。
因为他们是完全终于圣经的一派，所以这教律也同样是来源于圣经。
他们拒绝使用兵器。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“国与国不再拔剑相攻，他们也不再学习战事。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;–《旧约·以赛亚书·2章4节》
–《旧约·弥迦书·4章3节》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;“把剑收回原处！凡拿剑的，都会死在剑下。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;–《新约·马太福音·26章52节》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为这一点触发了很多的事件。
比如1996年，日本的分会中，有人拒绝上高中的剑道课，导致无法毕业。
再比如2000年前后，台湾分会中，拒绝服兵役时使用兵器，导致入狱。出狱后仍需服没有完成的兵役，再次因为拒绝使用兵器而入狱。如此反复。
再比如回溯到20世纪初期，纳粹德国时期，只有耶和华见证人作为一个宗教团体，拒绝迎合纳粹的种种要求：拒绝效忠国家和元首，拒绝参与军事行动。根据维基百科的叙述&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;結果，在德国，纳粹统治期间共有6262人被捕，2074人被关入集中营，有大約1200個耶和華見證人在納粹時期喪生，其中270人因良心緣故拒絕參與軍事服務而被處決。耶和華見證人表明自己與所信仰的完全一致：“我們必須接受上帝的統治，服從上帝而不是服從人。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;（使徒行傳5:29）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这种精神令人钦佩。什么算爱国。什么算爱人。
归根结底，用带我的偏见来讲的话，不愧是教授、学者创立的宗教。即便是宗教团体，也是这样的别出一格。
完全可以和xx门教做比较。&lt;/p&gt;

&lt;p&gt;当然，毕竟也是宗教，对于我这种皇帝炎帝信仰类的自然信仰者，不得不指出一句。
圣经中有如此的一句话。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“耶和华是我的牧者，我必一无所缺。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;“我虽然走在漆黑的谷中，却不怕受害，因为你与我同在，你的仗、你的竿都给我安慰。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;《旧约·诗篇·23章1节》《旧约·诗篇·23章4节》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;《圣经·新世界译本》&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%80%B6%E5%92%8C%E8%8F%AF%E8%A6%8B%E8%AD%89%E4%BA%BA#%E8%A2%AB%E8%BF%AB%E5%AE%B3%E5%8F%B2&quot;&gt;维基百科：耶和华见证人&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%9B%E3%83%90%E3%81%AE%E8%A8%BC%E4%BA%BA&quot;&gt;维基百科：エホバの証人&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="essay" /><summary type="html">所有的宗教团体中。我最敬佩的就是耶和华见证人。 历史上的宗教如此之多。宗教团体也很多。 我很喜欢自然宗教。比较符合原始生存的，自然信仰。比如，认为一切皆有灵的北欧信仰。比如，爱斯基摩对于杀戮之果的祭祀。再比如，亚洲大陆的萨满风俗（跳大神也是一种分支）。 他们迷信，但是无害。 不过自然信仰之所以抵挡不过后来的三大宗教，一个很大的原因就是没有一个强大的组织。他们并不知晓组织和团队力量的强大。 基督教的团体我也见过很多。很多。 比如摩尔门教，比如耶和华见证人。 耶和华见证人成立的时间不长，最初是一个教授创立的。 这个教派的教规很有趣。在有着通有的严于律己的教律同时，还有一条非常有趣的律己教律。 因为他们是完全终于圣经的一派，所以这教律也同样是来源于圣经。 他们拒绝使用兵器。 “国与国不再拔剑相攻，他们也不再学习战事。” –《旧约·以赛亚书·2章4节》 –《旧约·弥迦书·4章3节》 “把剑收回原处！凡拿剑的，都会死在剑下。” –《新约·马太福音·26章52节》 因为这一点触发了很多的事件。 比如1996年，日本的分会中，有人拒绝上高中的剑道课，导致无法毕业。 再比如2000年前后，台湾分会中，拒绝服兵役时使用兵器，导致入狱。出狱后仍需服没有完成的兵役，再次因为拒绝使用兵器而入狱。如此反复。 再比如回溯到20世纪初期，纳粹德国时期，只有耶和华见证人作为一个宗教团体，拒绝迎合纳粹的种种要求：拒绝效忠国家和元首，拒绝参与军事行动。根据维基百科的叙述 結果，在德国，纳粹统治期间共有6262人被捕，2074人被关入集中营，有大約1200個耶和華見證人在納粹時期喪生，其中270人因良心緣故拒絕參與軍事服務而被處決。耶和華見證人表明自己與所信仰的完全一致：“我們必須接受上帝的統治，服從上帝而不是服從人。” （使徒行傳5:29） 这种精神令人钦佩。什么算爱国。什么算爱人。 归根结底，用带我的偏见来讲的话，不愧是教授、学者创立的宗教。即便是宗教团体，也是这样的别出一格。 完全可以和xx门教做比较。 当然，毕竟也是宗教，对于我这种皇帝炎帝信仰类的自然信仰者，不得不指出一句。 圣经中有如此的一句话。 “耶和华是我的牧者，我必一无所缺。” “我虽然走在漆黑的谷中，却不怕受害，因为你与我同在，你的仗、你的竿都给我安慰。” 《旧约·诗篇·23章1节》《旧约·诗篇·23章4节》 参考资料： 《圣经·新世界译本》 维基百科：耶和华见证人 维基百科：エホバの証人</summary></entry><entry><title type="html">关于一不小心就变成了图灵完全的…</title><link href="http://localhost:4000/blog/tech_blog/tech/2018/02/23/somehow-becoming-tuning-complete.html" rel="alternate" type="text/html" title="关于一不小心就变成了图灵完全的..." /><published>2018-02-23T00:00:00+09:00</published><updated>2018-02-23T00:00:00+09:00</updated><id>http://localhost:4000/blog/tech_blog/tech/2018/02/23/somehow-becoming-tuning-complete</id><content type="html" xml:base="http://localhost:4000/blog/tech_blog/tech/2018/02/23/somehow-becoming-tuning-complete.html">&lt;p&gt;最近几天没做leetcode的题，工作太忙了。明明就要离职了55555….
就顺便偷个懒，写点好玩的东西。主要内容和灵感来自&lt;a href=&quot;https://cpplover.blogspot.jp/2013/10/blog-post_20.html&quot;&gt;这篇文章(https://cpplover.blogspot.jp/2013/10/blog-post_20.html)&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1什么是图灵完全&quot;&gt;1.什么是图灵完全&lt;/h3&gt;

&lt;p&gt;首先我们要明确一个概念。什么算是图灵完全。
简单来说，就是跟万能图灵机具有同等计算能力的计算模型，就可以称之为图灵完全。
图灵机可以看作是当代计算机的简化模型。基本上图灵机就是抽象化的基本计算机模型。&lt;/p&gt;

&lt;p&gt;一般而言，大多数当代的编程语言都是图灵完全的语言。
跟NP的概念很类似，同样具有图灵机概念的话，理论上互相做的事情都可以相互转换。
也就是说，c++能做的到的大多数事情，js同样也可以做到。&lt;/p&gt;

&lt;p&gt;再譬如令人惊讶的brainfuck这门语言，也同样是图灵完全语言。那么理论上，可以用c来bind brainfuck，
brain来bind c就算了….c写的东西可以转换成brainfuck，brainfuck写的东西也可以转换成c。&lt;/p&gt;

&lt;p&gt;我目前知道的4种证明一种语言是图灵完全语言的方法：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.用这种语言实现重复处理。(也就是可以实现finite automaton)&lt;/li&gt;
  &lt;li&gt;2.用这种语言实现&lt;a href=&quot;https://en.wikipedia.org/wiki/Rule_110&quot;&gt;rule 110&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;3.用这种语言实现&lt;a href=&quot;https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life&quot;&gt;life&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;4.用某种语言制作可以另一种已经被证明是图灵完全的语言的complier来证明，这个语言是图灵完全。(这个可以说是不用证明)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INPUT -&amp;gt; PROCESS -&amp;gt; OUTPUT
          ↑___|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2不小心就变成图灵完全的&quot;&gt;2.不小心就变成图灵完全的…&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;c++ template&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/189172/c-templates-turing-complete&quot;&gt;[1]stackoverflow&lt;/a&gt;
  &lt;a href=&quot;https://www.artima.com/cppsource/codefeaturesP.html&quot;&gt;[2]用c++ template实现一些work&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTML5 + CSS&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/2497146/is-css-turing-complete&quot;&gt;[3]stackoverflow&lt;/a&gt;
  &lt;a href=&quot;http://eli.fox-epste.in/rule110-full.html&quot;&gt;[4]用css来实现的rule 110&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;万智牌(Magic: The Gathering)&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://www.toothycat.net/~hologram/Turing/HowItWorks.html&quot;&gt;[5]用magic牌实现turning machine的解说（我没细读…）&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Minecraft&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?feature=player_embedded&amp;amp;v=7sNge0Ywz-M&quot;&gt;[6]用minecraft实现的简易compute的油管视频，这里的ROM是人肉（视频作者…）&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;神奇宝贝 黄 （ポケットモンスター　イエロー）&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://tasvideos.org/2913S.html&quot;&gt;[7]利用黄的一个bug，可以改写游戏的memory addresses，从而进行图灵完全的实现（这个有点牵强….）&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Tex&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://hak7a3.hatenablog.com/entry/2016/12/17/122422&quot;&gt;[8]用实现一个图灵完全语言的编译器(complier)来证明这个语言是图灵完全语言&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SQL&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://assets.en.oreilly.com/1/event/27/High%20Performance%20SQL%20with%20PostgreSQL%20Presentation.pdf&quot;&gt;[9]sql的图灵完全说明&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(Cプリプロセッサー)&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://www.ioccc.org/years.html#2001&quot;&gt;[10]参照2001年的IOCCC大会的herrmann1条目&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;写完之后才发现其实要看的东西还蛮多的，很多基础概念要么就是忘记了，要么就是原本就搞得不太清楚….&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://cpplover.blogspot.jp/2013/10/blog-post_20.html&quot;&gt;うっかりチューリング完全になっちゃったもの&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://d.hatena.ne.jp/zrbabbler/20140607/1402135613&quot;&gt;TeX はどうしてアレなのか&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://hak7a3.hatenablog.com/entry/2016/12/17/122422&quot;&gt;もうひとつのTeXがチューリング完全であることの証明&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://0-chromosome.hatenablog.jp/entry/2015/12/07/000000&quot;&gt;TeXで簡単プログラミング♪&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ja.wikipedia.org/wiki/%E3%83%81%E3%83%A5%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0%E5%AE%8C%E5%85%A8&quot;&gt;wikipedia:チューリング完全&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Turing_completeness&quot;&gt;Turing completeness&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="tech" /><category term="图灵" /><summary type="html">最近几天没做leetcode的题，工作太忙了。明明就要离职了55555…. 就顺便偷个懒，写点好玩的东西。主要内容和灵感来自这篇文章(https://cpplover.blogspot.jp/2013/10/blog-post_20.html)。 1.什么是图灵完全 首先我们要明确一个概念。什么算是图灵完全。 简单来说，就是跟万能图灵机具有同等计算能力的计算模型，就可以称之为图灵完全。 图灵机可以看作是当代计算机的简化模型。基本上图灵机就是抽象化的基本计算机模型。 一般而言，大多数当代的编程语言都是图灵完全的语言。 跟NP的概念很类似，同样具有图灵机概念的话，理论上互相做的事情都可以相互转换。 也就是说，c++能做的到的大多数事情，js同样也可以做到。 再譬如令人惊讶的brainfuck这门语言，也同样是图灵完全语言。那么理论上，可以用c来bind brainfuck， brain来bind c就算了….c写的东西可以转换成brainfuck，brainfuck写的东西也可以转换成c。 我目前知道的4种证明一种语言是图灵完全语言的方法： 1.用这种语言实现重复处理。(也就是可以实现finite automaton) 2.用这种语言实现rule 110。 3.用这种语言实现life。 4.用某种语言制作可以另一种已经被证明是图灵完全的语言的complier来证明，这个语言是图灵完全。(这个可以说是不用证明) INPUT -&amp;gt; PROCESS -&amp;gt; OUTPUT ↑___| 2.不小心就变成图灵完全的… c++ template [1]stackoverflow [2]用c++ template实现一些work HTML5 + CSS [3]stackoverflow [4]用css来实现的rule 110 万智牌(Magic: The Gathering) [5]用magic牌实现turning machine的解说（我没细读…） Minecraft [6]用minecraft实现的简易compute的油管视频，这里的ROM是人肉（视频作者…） 神奇宝贝 黄 （ポケットモンスター　イエロー） [7]利用黄的一个bug，可以改写游戏的memory addresses，从而进行图灵完全的实现（这个有点牵强….） Tex [8]用实现一个图灵完全语言的编译器(complier)来证明这个语言是图灵完全语言 SQL [9]sql的图灵完全说明 (Cプリプロセッサー) [10]参照2001年的IOCCC大会的herrmann1条目 写完之后才发现其实要看的东西还蛮多的，很多基础概念要么就是忘记了，要么就是原本就搞得不太清楚…. 参考资料： うっかりチューリング完全になっちゃったもの TeX はどうしてアレなのか もうひとつのTeXがチューリング完全であることの証明 TeXで簡単プログラミング♪ wikipedia:チューリング完全 Turing completeness</summary></entry><entry><title type="html">关于JAVA同期的初步学习笔记(2)</title><link href="http://localhost:4000/blog/tech_blog/tech/2018/02/14/about-java-sync.html" rel="alternate" type="text/html" title="关于JAVA同期的初步学习笔记(2)" /><published>2018-02-14T00:00:00+09:00</published><updated>2018-02-14T00:00:00+09:00</updated><id>http://localhost:4000/blog/tech_blog/tech/2018/02/14/about-java-sync</id><content type="html" xml:base="http://localhost:4000/blog/tech_blog/tech/2018/02/14/about-java-sync.html">&lt;p&gt;源于。。。。嗯。因为发现之前写过一个JAVA同期的东西。所以开了这个续集。&lt;/p&gt;

&lt;p&gt;前阵子做了一个cancel处理的一个小东西。好像是。。。组里的都嫌麻烦（？）反正最后玛德竟然抛给我了。
这是抛绣球么，净挑年轻的抛（？）我也很累的好么。&lt;/p&gt;

&lt;p&gt;简单来说是这么一个东西。
现有一个系统，是从browser端向DB传送数据。数据中途要经历大量的翻过来覆过去的转换类型，最后变成整整齐齐的一个个小表格塞到DB里面去。
ummmmm……..根据我的测试，server端的java里面的进程，大约是，100MB的数据，就会占据大约2GB的内存（RAM）。
本着不让server端迅速的因为大数据（咦？）而崩溃，目前已存的系统是这样设计的。&lt;/p&gt;

&lt;p&gt;允许一个账单的数据输入，不过是排队一个接着一个输入。
比如队列中有{a, b, c}三个文件，那么是按照顺序，先输入a，等a的处理结束之后从server端返回处理成功的response。等browser端接到response之后再开始b的处理。
同理c。&lt;/p&gt;

&lt;p&gt;使用方嫌等待时间太长了，要求出“取消”机能。这个很理解，我亲测，100MB的数据，我的小破电脑愣是跑了4-5个小时都没跑完。就算是workstation跑程序，就这个效率的话….
于是乎就跟文章开头一样，这个绣球最后就抛到我这里了= =||&lt;/p&gt;

&lt;p&gt;我考虑的有2点，
(1)不破坏现有结构。
(2)在现有结构基础上做到cancel处理。不留后遗症的cancel处理。&lt;/p&gt;

&lt;p&gt;我们可以把单个文件的处理过程大致分为5个过程。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;（1）从browser端发送数据之前的所有处理&lt;/li&gt;
  &lt;li&gt;（2）从browser端传送到server端的处理过程之中&lt;/li&gt;
  &lt;li&gt;（3）在server端进行数据的处理&lt;/li&gt;
  &lt;li&gt;（4）在server端数据处理结束之后，发送response之前&lt;/li&gt;
  &lt;li&gt;（5）browser端接受到response之前&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\stills\blog\20180214-java-sync-2\20180214-about-java-sync-2.png&quot; alt=&quot;process flow&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这里，（1）和（4）（5）基本是不用考虑的，在实际使用中需要考虑的是（2）~（3）。&lt;/p&gt;

&lt;p&gt;首先，这个处理是用xmlhttprequest来做的，那在传输数据的过程中，使用xhr自带的abort()可以取消（2）的处理过程。&lt;/p&gt;

&lt;p&gt;其次，要处理（3）的过程应当如何去做。tomcat是典型的多线程server，由于内部处理得当，所以处理数据的线程无法被其他的线程干扰。
也就是说，如果你发送一个cancel请求，事实上是无法直接遥控正在处理数据的线程的。
cancel处理可以使用thread自带的isInterrupted()这一属性，而想要遥控这个属性事实上也可以把这个thread的reference带走，譬如放到一个static的内部结构里面，
这样就可以用别的线程去遥控那个interrupted的属性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\stills\blog\20180214-java-sync-2\20180214-about-java-sync-2-2.png&quot; alt=&quot;cancel req&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果把thread的reference带出来也是可以。我们可以通过很多东西来确认一个独特的thread。比如sessionID + 现在的毫秒时间组成的独特的特征码。
这样的话我们把thread放到一个map里面就可以解决问题了。&lt;/p&gt;

&lt;p&gt;这里涉及到一个问题。如果不只是一个人在进行数据输入。不同进程同时处理一个static的map的话，会有小概率出问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\stills\blog\20180214-java-sync-2\20180214-about-java-sync-2-3.png&quot; alt=&quot;multithread cancel&quot; /&gt;&lt;/p&gt;

&lt;p&gt;经典的解决办法就是锁。在java里面是一个叫做synchronized的东西。简单而言，其实把整个method都上锁就可以轻易解决这一难题。（另一个据说很多JVM不按标准实装的volatile暂时不在讨论范围）
这里会涉及到一个效率问题。就是，如果锁的时间过长，会拖慢整个程序。如下面的参考资料，我事实上考虑过使用singleton的双重锁来解决不要static一开始就占用一块内存的地盘的效率问题。
不过在考虑诸多之后，因为原本想要锁住的操作也很简单，我就没有采用那种pattern。
我的做法是，cancel request来了之后，直接用上文的sessionID + 现在的毫秒时间组成的特征码来查看map中是否有thread的reference，有的话执行interrupt，没有的话直接放弃，不管cancel request的死活。
这样的话并不会出现锁住整个进程的问题。&lt;/p&gt;

&lt;p&gt;这样（3）也解决了。&lt;/p&gt;

&lt;p&gt;就这么愉快的解决了这个问题。说起来废话很多，也是因为一开始做了很多想法，比如储存cancel request，这样可以把cancel request的成败也通知browser端。
但是这样产生了别的问题，如果是恰巧在(4)和(5)之间的时候来的cancel request，就必须要把cancel request删除，不然会永久的留在内存之中。
这样的话要做一个可以定期自动删除数据的map…um……倒不是做不到XD 但是效率未免会太差了点。&lt;/p&gt;

&lt;p&gt;PS：
对了，记得知乎上的轮子哥曾经说过，如果只用getter，就不用同期锁。如果只要有一个进程要用setter，那就要做同期锁，而且要getter和setter同时上锁。&lt;/p&gt;

&lt;p&gt;仔细想想很有道理，不然如果只setter上锁，getter不上锁，在get的瞬间，数据还没得到的时候，但是代码已经执行结束的瞬间，如果被setter换了数据，那么就会得到不一样的数据。这样怎么想都有点风险。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://tomcat.apache.org/tomcat-8.0-doc/&quot;&gt;tomcat 8 reference&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/30721261/java-threads-and-thread-interrupts&quot;&gt;Java threads and thread interrupts&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.yuku-t.com/entry/20110225/1298567486&quot;&gt;JavaでSingletonパターンを実装するのにclassとenumのどちらを使うべきか&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qiita.com/neko_the_shadow/items/1879e8a8e6aec0e86845&quot;&gt;enumを利用したSingleton実装のサンプルコード&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/31409982/java-best-practice-class-with-only-static-methods/31410051&quot;&gt;Java best practice: Class with only static methods&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons&quot;&gt;What is so bad about singletons?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4074154/when-should-the-singleton-pattern-not-be-used-besides-the-obvious&quot;&gt;When should the Singleton pattern NOT be used?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;没太大关联的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/14223150/mapping-a-specific-servlet-to-be-the-default-servlet-in-tomcat/14225540&quot;&gt;Mapping a specific servlet to be the default servlet in Tomcat&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://d.hatena.ne.jp/daisuke-m/20100414/1271228333&quot;&gt;[Java]難解なSerializableという仕様について俺が知っていること、というか俺の理解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="tech" /><category term="java," /><category term="sync," /><category term="multithread" /><summary type="html">源于。。。。嗯。因为发现之前写过一个JAVA同期的东西。所以开了这个续集。 前阵子做了一个cancel处理的一个小东西。好像是。。。组里的都嫌麻烦（？）反正最后玛德竟然抛给我了。 这是抛绣球么，净挑年轻的抛（？）我也很累的好么。 简单来说是这么一个东西。 现有一个系统，是从browser端向DB传送数据。数据中途要经历大量的翻过来覆过去的转换类型，最后变成整整齐齐的一个个小表格塞到DB里面去。 ummmmm……..根据我的测试，server端的java里面的进程，大约是，100MB的数据，就会占据大约2GB的内存（RAM）。 本着不让server端迅速的因为大数据（咦？）而崩溃，目前已存的系统是这样设计的。 允许一个账单的数据输入，不过是排队一个接着一个输入。 比如队列中有{a, b, c}三个文件，那么是按照顺序，先输入a，等a的处理结束之后从server端返回处理成功的response。等browser端接到response之后再开始b的处理。 同理c。 使用方嫌等待时间太长了，要求出“取消”机能。这个很理解，我亲测，100MB的数据，我的小破电脑愣是跑了4-5个小时都没跑完。就算是workstation跑程序，就这个效率的话…. 于是乎就跟文章开头一样，这个绣球最后就抛到我这里了= =|| 我考虑的有2点， (1)不破坏现有结构。 (2)在现有结构基础上做到cancel处理。不留后遗症的cancel处理。 我们可以把单个文件的处理过程大致分为5个过程。 （1）从browser端发送数据之前的所有处理 （2）从browser端传送到server端的处理过程之中 （3）在server端进行数据的处理 （4）在server端数据处理结束之后，发送response之前 （5）browser端接受到response之前 在这里，（1）和（4）（5）基本是不用考虑的，在实际使用中需要考虑的是（2）~（3）。 首先，这个处理是用xmlhttprequest来做的，那在传输数据的过程中，使用xhr自带的abort()可以取消（2）的处理过程。 其次，要处理（3）的过程应当如何去做。tomcat是典型的多线程server，由于内部处理得当，所以处理数据的线程无法被其他的线程干扰。 也就是说，如果你发送一个cancel请求，事实上是无法直接遥控正在处理数据的线程的。 cancel处理可以使用thread自带的isInterrupted()这一属性，而想要遥控这个属性事实上也可以把这个thread的reference带走，譬如放到一个static的内部结构里面， 这样就可以用别的线程去遥控那个interrupted的属性。 如果把thread的reference带出来也是可以。我们可以通过很多东西来确认一个独特的thread。比如sessionID + 现在的毫秒时间组成的独特的特征码。 这样的话我们把thread放到一个map里面就可以解决问题了。 这里涉及到一个问题。如果不只是一个人在进行数据输入。不同进程同时处理一个static的map的话，会有小概率出问题。 经典的解决办法就是锁。在java里面是一个叫做synchronized的东西。简单而言，其实把整个method都上锁就可以轻易解决这一难题。（另一个据说很多JVM不按标准实装的volatile暂时不在讨论范围） 这里会涉及到一个效率问题。就是，如果锁的时间过长，会拖慢整个程序。如下面的参考资料，我事实上考虑过使用singleton的双重锁来解决不要static一开始就占用一块内存的地盘的效率问题。 不过在考虑诸多之后，因为原本想要锁住的操作也很简单，我就没有采用那种pattern。 我的做法是，cancel request来了之后，直接用上文的sessionID + 现在的毫秒时间组成的特征码来查看map中是否有thread的reference，有的话执行interrupt，没有的话直接放弃，不管cancel request的死活。 这样的话并不会出现锁住整个进程的问题。 这样（3）也解决了。 就这么愉快的解决了这个问题。说起来废话很多，也是因为一开始做了很多想法，比如储存cancel request，这样可以把cancel request的成败也通知browser端。 但是这样产生了别的问题，如果是恰巧在(4)和(5)之间的时候来的cancel request，就必须要把cancel request删除，不然会永久的留在内存之中。 这样的话要做一个可以定期自动删除数据的map…um……倒不是做不到XD 但是效率未免会太差了点。 PS： 对了，记得知乎上的轮子哥曾经说过，如果只用getter，就不用同期锁。如果只要有一个进程要用setter，那就要做同期锁，而且要getter和setter同时上锁。 仔细想想很有道理，不然如果只setter上锁，getter不上锁，在get的瞬间，数据还没得到的时候，但是代码已经执行结束的瞬间，如果被setter换了数据，那么就会得到不一样的数据。这样怎么想都有点风险。 参考资料： tomcat 8 reference Java threads and thread interrupts JavaでSingletonパターンを実装するのにclassとenumのどちらを使うべきか enumを利用したSingleton実装のサンプルコード Java best practice: Class with only static methods What is so bad about singletons? When should the Singleton pattern NOT be used? 没太大关联的： Mapping a specific servlet to be the default servlet in Tomcat [Java]難解なSerializableという仕様について俺が知っていること、というか俺の理解</summary></entry><entry><title type="html">什么是pointer</title><link href="http://localhost:4000/blog/tech_blog/tech/2018/02/13/what-is-a-pointer.html" rel="alternate" type="text/html" title="什么是pointer" /><published>2018-02-13T00:00:00+09:00</published><updated>2018-02-13T00:00:00+09:00</updated><id>http://localhost:4000/blog/tech_blog/tech/2018/02/13/what-is-a-pointer</id><content type="html" xml:base="http://localhost:4000/blog/tech_blog/tech/2018/02/13/what-is-a-pointer.html">&lt;p&gt;写同期之前，写一个基础小知识吧。一个小学弟（初学者）问我什么是指针。
ummmm…….
这要用手机打字的话，估计会写到自己崩溃吧XD 恰巧身边有电脑，就记录一下。顺便把这个文章给他分享下XD&lt;/p&gt;

&lt;p&gt;pointer我记得汉语翻译是指针，一般是c和c++中特有的一个概念。不过php中也有类似于指针的东西，至于具体名字是不是指针我就不清楚了。&lt;/p&gt;

&lt;p&gt;想要理解指针，首先要理解的一个事情就是，内存(RAM)的作用。暂且抛却heap和stack的区别。我们在程序中所书写的所有变量(variable),函数(function)都是存储在内存之中的。
为什么存储在内存中？当然是速度快啊！当然你也可以在硬盘中一点一点读取，边用边读，当然这就是另一个话题了。
因为所有的数据都存储在RAM之中，
所以我们使用数据的进行计算的时候，也对应的要从内存中选择。
我学弟学习的是c++，我就用c++举例子好了。（不然我想用js的说TAT）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int a = 0;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里的a就是指向内存中的一块被宣言成为int的一小块区域。大小是根据你系统的bit数而决定的，64bit还是32bit的话，大小也会不一样。
当然，除了基本类型，譬如stl库中的类型，也同样是被存储在内存中的。就比如下面的v就是例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;int&amp;gt; v;
v.push_back(233);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是在传递数值的时候会产生一个问题。在譬如js，或者java一类的所谓的高等语言中，一般是会不让编程者注意到这一信息。事实上这一信息会产生一定的速度差异和优势，当然也会产生相应的编程困扰。
废话讲的有点多。暂且抛弃c++中的参照(reference)的概念，用pointer写一个简单的例子。
继续我们的基础类型int的例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int a = 233;
int* b = &amp;amp;a;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意我们的宣言，是int&lt;em&gt;，我们的类型是int&lt;/em&gt;。当然你写成&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int *b = &amp;amp;a;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;也是没有任何的错误的。&lt;/p&gt;

&lt;p&gt;这时，这个int*类型的b就是一个pointer。他指向的是a。
什么意思呢。原本我们的a，就指向的是RAM中的一个宣言为int类型的一个小空间。如果我们&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int c = a;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;那么我们所做的，是在RAM中再确立了另一块小空间，用c来指向那里，然后把a的数值copy过去。&lt;/p&gt;

&lt;p&gt;但是我们int*类型的b所做的，就是直接指向了a的空间。&lt;/p&gt;

&lt;p&gt;事实上不必怀疑，int*类型本身也是会占据一定的RAM空间的，当然这是后话。&lt;/p&gt;

&lt;p&gt;那么这样做会带来一个问题。就是，如果a的数值变了的话，会怎么样。
答案很简单。因为a的数值变了的话，a在RAM空间的数值会变化，所以b的数值也会变。但是c因为是在RAM空间的另一块区域开启的新空间，所以，a的空间变的怎样，其实是没有任何关系的。
所以即便a的数值产生了变化，c的数值也不会变。&lt;/p&gt;

&lt;p&gt;这就是pointer和普通变量(variable)的区别。pointer赋予我们的是直接操作RAM的能力。当然会有少许的性能代价(pointer本身也会占据内存)。也会有相当程度的风险，比如memory leak。
（爱，老哥我毕业论文就差点因为不小心写出了memory leak没法用程序验证理论，险些GG。多亏了valgrind这个神程序。。。。）&lt;/p&gt;

&lt;p&gt;当然，c和c++语言中的pointer，当然是不仅仅只有这个功能，还跟array有着密不可分的关系，所以说c写起来才让人头疼啊。。。。&lt;/p&gt;

&lt;p&gt;PS：这个array的汉语翻译我没找到。。。
这个等我今天晚上回家再继续码字吧！&lt;/p&gt;

&lt;p&gt;参考资料：
暂无。&lt;/p&gt;</content><author><name></name></author><category term="tech" /><category term="c,c++" /><summary type="html">写同期之前，写一个基础小知识吧。一个小学弟（初学者）问我什么是指针。 ummmm……. 这要用手机打字的话，估计会写到自己崩溃吧XD 恰巧身边有电脑，就记录一下。顺便把这个文章给他分享下XD pointer我记得汉语翻译是指针，一般是c和c++中特有的一个概念。不过php中也有类似于指针的东西，至于具体名字是不是指针我就不清楚了。 想要理解指针，首先要理解的一个事情就是，内存(RAM)的作用。暂且抛却heap和stack的区别。我们在程序中所书写的所有变量(variable),函数(function)都是存储在内存之中的。 为什么存储在内存中？当然是速度快啊！当然你也可以在硬盘中一点一点读取，边用边读，当然这就是另一个话题了。 因为所有的数据都存储在RAM之中， 所以我们使用数据的进行计算的时候，也对应的要从内存中选择。 我学弟学习的是c++，我就用c++举例子好了。（不然我想用js的说TAT） int a = 0; 这里的a就是指向内存中的一块被宣言成为int的一小块区域。大小是根据你系统的bit数而决定的，64bit还是32bit的话，大小也会不一样。 当然，除了基本类型，譬如stl库中的类型，也同样是被存储在内存中的。就比如下面的v就是例子。 std::vector&amp;lt;int&amp;gt; v; v.push_back(233); 但是在传递数值的时候会产生一个问题。在譬如js，或者java一类的所谓的高等语言中，一般是会不让编程者注意到这一信息。事实上这一信息会产生一定的速度差异和优势，当然也会产生相应的编程困扰。 废话讲的有点多。暂且抛弃c++中的参照(reference)的概念，用pointer写一个简单的例子。 继续我们的基础类型int的例子。 int a = 233; int* b = &amp;amp;a; 注意我们的宣言，是int，我们的类型是int。当然你写成 int *b = &amp;amp;a; 也是没有任何的错误的。 这时，这个int*类型的b就是一个pointer。他指向的是a。 什么意思呢。原本我们的a，就指向的是RAM中的一个宣言为int类型的一个小空间。如果我们 int c = a; 那么我们所做的，是在RAM中再确立了另一块小空间，用c来指向那里，然后把a的数值copy过去。 但是我们int*类型的b所做的，就是直接指向了a的空间。 事实上不必怀疑，int*类型本身也是会占据一定的RAM空间的，当然这是后话。 那么这样做会带来一个问题。就是，如果a的数值变了的话，会怎么样。 答案很简单。因为a的数值变了的话，a在RAM空间的数值会变化，所以b的数值也会变。但是c因为是在RAM空间的另一块区域开启的新空间，所以，a的空间变的怎样，其实是没有任何关系的。 所以即便a的数值产生了变化，c的数值也不会变。 这就是pointer和普通变量(variable)的区别。pointer赋予我们的是直接操作RAM的能力。当然会有少许的性能代价(pointer本身也会占据内存)。也会有相当程度的风险，比如memory leak。 （爱，老哥我毕业论文就差点因为不小心写出了memory leak没法用程序验证理论，险些GG。多亏了valgrind这个神程序。。。。） 当然，c和c++语言中的pointer，当然是不仅仅只有这个功能，还跟array有着密不可分的关系，所以说c写起来才让人头疼啊。。。。 PS：这个array的汉语翻译我没找到。。。 这个等我今天晚上回家再继续码字吧！ 参考资料： 暂无。</summary></entry><entry><title type="html">不朽</title><link href="http://localhost:4000/blog/essay_blog/essay/2018/02/12/essay-about-forever.html" rel="alternate" type="text/html" title="不朽" /><published>2018-02-12T00:00:00+09:00</published><updated>2018-02-12T00:00:00+09:00</updated><id>http://localhost:4000/blog/essay_blog/essay/2018/02/12/essay-about-forever</id><content type="html" xml:base="http://localhost:4000/blog/essay_blog/essay/2018/02/12/essay-about-forever.html">&lt;p&gt;不知是受什么影响。我总觉得想是在世间留下点什么。可能大约是小学3年级时候开始思索的人生的意义。也可能是一些其他的别的。&lt;/p&gt;

&lt;p&gt;高晓松曾经说过一个很有趣的现象。我国有很多出名的书法家。但是却很少有出名的音乐家。不止是本代如此，历朝历代历来如此，就好像是一个民族性一样。
非要说理由的话很多吧。
高晓松接着还说过另一个有趣的现象。一首流传度高的中文歌曲，往往都是歌词也十分优秀的。
想来确实是如此。
如果歌词没有内涵，往往会被批判的很厉害。
也没准就真的是什么民族性。或者准确点说，是一种文化。&lt;/p&gt;

&lt;p&gt;我喜欢历史。从小就喜欢。我想应该不是喜欢什么枯燥的文字，从文字当中找寻着什么。
我喜欢的是故事。我喜欢听故事，如果可能，我也喜欢讲故事。
同样的，记录历史的，永远是文字。当然文字之前还有壁画。不过很可惜壁画的内容基本只能靠猜。
我喜欢写日记。
我也喜欢记录下真实的一切。
不过其实我，并不喜欢电子制品。那里面的数据太容易丢失了。
留不了很久的。&lt;/p&gt;

&lt;p&gt;远的不说，硬盘中的数据能不能留个10年以上，都不好说。
那理论上都已经超出了硬盘设计初衷的使用寿命，不是麽。
刨除自己的硬盘，网络上的所谓云硬盘也是一样。
当年的百度空间。在当年还是百度粉的我，以为百度空间永远都不会倒。
谁知道，这东西也都是说没就没。就好像什么都没发生过，什么都没有经历过。&lt;/p&gt;

&lt;p&gt;我曾经以为，音乐只是听个响。留不下太久的记忆。
但是我渐渐的发现，文字其实不也是一样么。
幼稚的是我，而不是渴望音乐不朽的音乐人。&lt;/p&gt;

&lt;p&gt;没什么可以不朽。谁都懂的道理。如果想要留得时间长一点。其实，未必是要在乎保存的媒介，而更应该注意的是保存的方法。
既然我有着想留下点什么的执念，那如果想要达成的话就也要做相应的准备才行，而不是纠结于，保存的媒介，这种肤浅的事情。
这点安全学里面已经讲的很清楚了，分担风险，就要留底牌。简单来说，呵呵，比如码字，那就要硬盘留一份，usb留一份，云端留一份，笑笑。
虽然麻烦，但是可行。&lt;/p&gt;</content><author><name></name></author><category term="essay" /><summary type="html">不知是受什么影响。我总觉得想是在世间留下点什么。可能大约是小学3年级时候开始思索的人生的意义。也可能是一些其他的别的。 高晓松曾经说过一个很有趣的现象。我国有很多出名的书法家。但是却很少有出名的音乐家。不止是本代如此，历朝历代历来如此，就好像是一个民族性一样。 非要说理由的话很多吧。 高晓松接着还说过另一个有趣的现象。一首流传度高的中文歌曲，往往都是歌词也十分优秀的。 想来确实是如此。 如果歌词没有内涵，往往会被批判的很厉害。 也没准就真的是什么民族性。或者准确点说，是一种文化。 我喜欢历史。从小就喜欢。我想应该不是喜欢什么枯燥的文字，从文字当中找寻着什么。 我喜欢的是故事。我喜欢听故事，如果可能，我也喜欢讲故事。 同样的，记录历史的，永远是文字。当然文字之前还有壁画。不过很可惜壁画的内容基本只能靠猜。 我喜欢写日记。 我也喜欢记录下真实的一切。 不过其实我，并不喜欢电子制品。那里面的数据太容易丢失了。 留不了很久的。 远的不说，硬盘中的数据能不能留个10年以上，都不好说。 那理论上都已经超出了硬盘设计初衷的使用寿命，不是麽。 刨除自己的硬盘，网络上的所谓云硬盘也是一样。 当年的百度空间。在当年还是百度粉的我，以为百度空间永远都不会倒。 谁知道，这东西也都是说没就没。就好像什么都没发生过，什么都没有经历过。 我曾经以为，音乐只是听个响。留不下太久的记忆。 但是我渐渐的发现，文字其实不也是一样么。 幼稚的是我，而不是渴望音乐不朽的音乐人。 没什么可以不朽。谁都懂的道理。如果想要留得时间长一点。其实，未必是要在乎保存的媒介，而更应该注意的是保存的方法。 既然我有着想留下点什么的执念，那如果想要达成的话就也要做相应的准备才行，而不是纠结于，保存的媒介，这种肤浅的事情。 这点安全学里面已经讲的很清楚了，分担风险，就要留底牌。简单来说，呵呵，比如码字，那就要硬盘留一份，usb留一份，云端留一份，笑笑。 虽然麻烦，但是可行。</summary></entry><entry><title type="html">记录网站重构为nginx</title><link href="http://localhost:4000/blog/tech_blog/tech/2018/01/28/update-site.html" rel="alternate" type="text/html" title="记录网站重构为nginx" /><published>2018-01-28T00:00:00+09:00</published><updated>2018-01-28T00:00:00+09:00</updated><id>http://localhost:4000/blog/tech_blog/tech/2018/01/28/update-site</id><content type="html" xml:base="http://localhost:4000/blog/tech_blog/tech/2018/01/28/update-site.html">&lt;p&gt;近几天打算续写java的同期。因为做了一个cancel的多线程的东西，有了些许心得故续写。&lt;/p&gt;

&lt;p&gt;最早写tech博客是为了炫耀技巧。但是每次执笔的时候都发现，自己真是太菜了= = 没啥子好写的。每次都查着资料，查着查着就跑去打游戏去了&lt;span&gt;（喂！ヽ(●-`Д´-)ノ）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;但是现在发现，自己好菜，记不住自己曾经写过的东西= =。。。&lt;/p&gt;

&lt;p&gt;当然，我也知道这是人之常情，twitter上有个话题，就是各大出名library的作者，各种讨论自己花样记不住自己写的API的事情。编程中也有一个说法，叫做programmer永远记不住自己一个月以前写过的东西。&lt;/p&gt;

&lt;p&gt;由于。。。自己真的记不太住自己之前是如何用apache2来构建的网站（注释基本没有留。。。）所以这次只是简单记录如何简单的构筑nginx网站。
而且以后，&lt;strong&gt;也专心的记录自己写过的东西，防止忘了！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.首先，由于apache2正在运行，要先关闭掉apache2。&lt;/p&gt;

&lt;p&gt;不然，安装nginx之后，会自动开始运行nginx的service。之后会出错，导致你无法正确安装程序。但是可以删除程序！
可以先去验证是不是安装包出错了，再可以验证是不是sudo权限被占用。都不是的话，那就是apache的锅，（当然也可能是其他问题）关掉apache的service，重启nginx。就可以解决。&lt;/p&gt;

&lt;p&gt;2.nginx的configure&lt;/p&gt;

&lt;p&gt;apache的历史包袱很重，没有对比就没有伤害，nginx的conf文件，完全是类JSON形式的，只不过区别是尾巴一定要加上“；”。估计是为了方便complier处理以及为了可以缩写成一行吧。
JSON形式真的太好写了，而且非常易懂。&lt;/p&gt;

&lt;p&gt;举个例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http{
  server{
    listen 80;
    server_name candy-water.com;
    location / {
      root /abc/def;
    }
    error_page 406 /404.html;
  }

  if($scheme ！= &quot;https&quot;){
    return 301 https://$host$request_uri;
  } # 这里是cerbot帮忙写的
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;基本上已经不需要解释了= =&lt;/p&gt;

&lt;p&gt;本来多个virtual domain，我还打算找网上的资料。。。但是这一看就懂了。。。
我就多写了几个server，把server_name换了一下。。。。就成了。
不像apache，要写好多个小文件0.0  当然不写小文件应该也是可以做到的。&lt;/p&gt;

&lt;p&gt;后来查了一下资料。location所代表的意思是，类似于java servlet里面的url pattern，可以把url读取，然后转换为｛｝里面包裹的地址返回。
下次可以做个fast cgi试试。
我有尝试把http2放进去，不过我发现即便没有放，firefox会自动发送http2的get request（通过检查f12的network）。
所以事实上不放也是可以的。下次再仔细研究一下。
基本构建就是如此了，&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://qiita.com/Aruneko/items/8c11f9e45a33457c3c1f&quot;&gt;NginxでHTTP2を有効にする&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://nginx.org/en/docs/beginners_guide.html&quot;&gt;Nginx Beginner’s Guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://certbot.eff.org/#ubuntutyakkety-nginx&quot;&gt;cert-bot-nginx&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qiita.com/katzueno/items/44e02db2f1bfa0de5860&quot;&gt;nginx コマンド超シンプル早見表&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cyberciti.biz/faq/star-stop-restart-apache2-webserver/&quot;&gt;Start / Stop and Restart Apache 2 Web Server Command&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.skyarch.net/blog/?p=7088&quot;&gt;nginxのrewriteを使ったリダイレクト&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qiita.com/ryounagaoka/items/fd641e39a196b47db875&quot;&gt;Nginxのエラーページをカスタマイズする方法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://heartbeats.jp/hbblog/2012/04/nginx05.html&quot;&gt;nginx連載5回目: nginxの設定、その3 - locationディレクティブ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-set-up-nginx-server-blocks-virtual-hosts-on-ubuntu-14-04-lts&quot;&gt;How To Set Up Nginx Server Blocks (Virtual Hosts) on Ubuntu 14.04 LTS &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="tech" /><category term="nginx," /><summary type="html">近几天打算续写java的同期。因为做了一个cancel的多线程的东西，有了些许心得故续写。 最早写tech博客是为了炫耀技巧。但是每次执笔的时候都发现，自己真是太菜了= = 没啥子好写的。每次都查着资料，查着查着就跑去打游戏去了（喂！ヽ(●-`Д´-)ノ） 但是现在发现，自己好菜，记不住自己曾经写过的东西= =。。。 当然，我也知道这是人之常情，twitter上有个话题，就是各大出名library的作者，各种讨论自己花样记不住自己写的API的事情。编程中也有一个说法，叫做programmer永远记不住自己一个月以前写过的东西。 由于。。。自己真的记不太住自己之前是如何用apache2来构建的网站（注释基本没有留。。。）所以这次只是简单记录如何简单的构筑nginx网站。 而且以后，也专心的记录自己写过的东西，防止忘了！ 1.首先，由于apache2正在运行，要先关闭掉apache2。 不然，安装nginx之后，会自动开始运行nginx的service。之后会出错，导致你无法正确安装程序。但是可以删除程序！ 可以先去验证是不是安装包出错了，再可以验证是不是sudo权限被占用。都不是的话，那就是apache的锅，（当然也可能是其他问题）关掉apache的service，重启nginx。就可以解决。 2.nginx的configure apache的历史包袱很重，没有对比就没有伤害，nginx的conf文件，完全是类JSON形式的，只不过区别是尾巴一定要加上“；”。估计是为了方便complier处理以及为了可以缩写成一行吧。 JSON形式真的太好写了，而且非常易懂。 举个例子。 http{ server{ listen 80; server_name candy-water.com; location / { root /abc/def; } error_page 406 /404.html; } if($scheme ！= &quot;https&quot;){ return 301 https://$host$request_uri; } # 这里是cerbot帮忙写的 } 基本上已经不需要解释了= = 本来多个virtual domain，我还打算找网上的资料。。。但是这一看就懂了。。。 我就多写了几个server，把server_name换了一下。。。。就成了。 不像apache，要写好多个小文件0.0 当然不写小文件应该也是可以做到的。 后来查了一下资料。location所代表的意思是，类似于java servlet里面的url pattern，可以把url读取，然后转换为｛｝里面包裹的地址返回。 下次可以做个fast cgi试试。 我有尝试把http2放进去，不过我发现即便没有放，firefox会自动发送http2的get request（通过检查f12的network）。 所以事实上不放也是可以的。下次再仔细研究一下。 基本构建就是如此了， 参考资料： NginxでHTTP2を有効にする Nginx Beginner’s Guide cert-bot-nginx nginx コマンド超シンプル早見表 Start / Stop and Restart Apache 2 Web Server Command nginxのrewriteを使ったリダイレクト Nginxのエラーページをカスタマイズする方法 nginx連載5回目: nginxの設定、その3 - locationディレクティブ How To Set Up Nginx Server Blocks (Virtual Hosts) on Ubuntu 14.04 LTS</summary></entry><entry><title type="html">Lover</title><link href="http://localhost:4000/blog/essay_blog/essay/2017/12/04/essay-lover.html" rel="alternate" type="text/html" title="Lover" /><published>2017-12-04T00:00:00+09:00</published><updated>2017-12-04T00:00:00+09:00</updated><id>http://localhost:4000/blog/essay_blog/essay/2017/12/04/essay-lover</id><content type="html" xml:base="http://localhost:4000/blog/essay_blog/essay/2017/12/04/essay-lover.html">&lt;p&gt;比起梦一般的Natsu&lt;/p&gt;

&lt;p&gt;现在很多时候更多会想起Koto&lt;/p&gt;

&lt;p&gt;想起那次在车站偶然相遇时 她的那张疲惫  满面油光的  显着老态的脸&lt;/p&gt;

&lt;p&gt;心底里猛地揪起来一句话&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;与你年轻时的面貌相比,我更爱你现在备受摧残的容颜&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;杜拉斯&lt;情人&gt;&lt;/情人&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;车站时的Koto可爱不再&lt;/p&gt;

&lt;p&gt;我却没有一丝的厌倦&lt;/p&gt;

&lt;p&gt;我还是喜欢着的&lt;/p&gt;

&lt;p&gt;从那张就可以回想起高中刚开学的脸&lt;/p&gt;

&lt;p&gt;高中刚开学那天的第一次见面&lt;/p&gt;

&lt;p&gt;就好像天使一般的笑容&lt;/p&gt;

&lt;p&gt;就从那张脸上咧开&lt;/p&gt;

&lt;p&gt;就从这张似是老去的脸上浮出来，&lt;/p&gt;

&lt;p&gt;依稀她高中的模样&lt;/p&gt;</content><author><name></name></author><category term="essay" /><category term="access," /><category term="sql" /><summary type="html">比起梦一般的Natsu 现在很多时候更多会想起Koto 想起那次在车站偶然相遇时 她的那张疲惫 满面油光的 显着老态的脸 心底里猛地揪起来一句话 与你年轻时的面貌相比,我更爱你现在备受摧残的容颜 杜拉斯 车站时的Koto可爱不再 我却没有一丝的厌倦 我还是喜欢着的 从那张就可以回想起高中刚开学的脸 高中刚开学那天的第一次见面 就好像天使一般的笑容 就从那张脸上咧开 就从这张似是老去的脸上浮出来， 依稀她高中的模样</summary></entry><entry><title type="html">今日头痛</title><link href="http://localhost:4000/blog/essay_blog/essay/2017/12/03/essay-headache.html" rel="alternate" type="text/html" title="今日头痛" /><published>2017-12-03T00:00:00+09:00</published><updated>2017-12-03T00:00:00+09:00</updated><id>http://localhost:4000/blog/essay_blog/essay/2017/12/03/essay-headache</id><content type="html" xml:base="http://localhost:4000/blog/essay_blog/essay/2017/12/03/essay-headache.html">&lt;p&gt;今日头疼。&lt;/p&gt;

&lt;p&gt;把电脑的cpu换成8700k。
再一次感受到了电子数据的脆弱。&lt;/p&gt;

&lt;p&gt;c盘的数据被彻底抹除——原本是可以复原的，但是win10自动更新后自动重启的设定让我措手不及。
win10自动更新新版本，重启，上一个版本的被保存到windows.old文件夹里。
原本的在windows.old里的资料全部被抹除掉重写。&lt;/p&gt;

&lt;p&gt;所有数据全部消失。&lt;/p&gt;

&lt;p&gt;那就，换回纸制品吧。&lt;/p&gt;

&lt;p&gt;但是纸质数据的碎片化——真的会找不到想找的东西。我不会魔法。没办法把这一切弄得很好很好。&lt;/p&gt;

&lt;p&gt;头痛。一天的整头痛。&lt;/p&gt;

&lt;p&gt;似乎是睡眠时房间温度太低。脑袋吃不消，就开始作痛。&lt;/p&gt;

&lt;p&gt;等到晚上11点左右，终于把电脑各种设定都设置好。调教周全。&lt;/p&gt;

&lt;p&gt;开始听歌。听音乐。真的恢复了好多。身体就像略有康复一般。&lt;/p&gt;

&lt;p&gt;有音乐真好。&lt;/p&gt;

&lt;p&gt;虽然视力仍然只能看清2米远。不过算了。&lt;/p&gt;

&lt;p&gt;能活着就真的很幸运了。&lt;/p&gt;</content><author><name></name></author><category term="essay" /><category term="access," /><category term="sql" /><summary type="html">今日头疼。 把电脑的cpu换成8700k。 再一次感受到了电子数据的脆弱。 c盘的数据被彻底抹除——原本是可以复原的，但是win10自动更新后自动重启的设定让我措手不及。 win10自动更新新版本，重启，上一个版本的被保存到windows.old文件夹里。 原本的在windows.old里的资料全部被抹除掉重写。 所有数据全部消失。 那就，换回纸制品吧。 但是纸质数据的碎片化——真的会找不到想找的东西。我不会魔法。没办法把这一切弄得很好很好。 头痛。一天的整头痛。 似乎是睡眠时房间温度太低。脑袋吃不消，就开始作痛。 等到晚上11点左右，终于把电脑各种设定都设置好。调教周全。 开始听歌。听音乐。真的恢复了好多。身体就像略有康复一般。 有音乐真好。 虽然视力仍然只能看清2米远。不过算了。 能活着就真的很幸运了。</summary></entry><entry><title type="html">近期短记</title><link href="http://localhost:4000/blog/essay_blog/essay/2017/11/22/essay-recent-record.html" rel="alternate" type="text/html" title="近期短记" /><published>2017-11-22T00:00:00+09:00</published><updated>2017-11-22T00:00:00+09:00</updated><id>http://localhost:4000/blog/essay_blog/essay/2017/11/22/essay-recent-record</id><content type="html" xml:base="http://localhost:4000/blog/essay_blog/essay/2017/11/22/essay-recent-record.html">&lt;p&gt;哇。写到一半。在notepad++上写到一半然后电脑就崩溃了。吓得我和我的小伙伴们都惊呆了。
竟然连备份都没有。
没办法，这个五年多的电脑变得越来越不安定。
可能是我之前安装cpu风扇的时候，那个散热的胶让我不小心涂在了边缘。
可能是我之前拆cpu的时候，不小心撞坏了顶针。
总之我也不知道是什么样的鬼原因吧。我是想换一台电脑了–起码换个cpu。
但是鉴于同等配置的笔记本的高昂价格。我决定依旧台式。&lt;/p&gt;

&lt;p&gt;今天7点就下班了。竟然只加班了半个小时。我也觉得挺不可思议的。
我还以为大家都忘记了正常的下班时间（当然我总是忘记正常的上班时间），
这次竟然没有在下班时间之后再给我安排任务。&lt;/p&gt;

&lt;p&gt;我微微一笑。忍着头痛，踏上了回家的旅程。
头痛不负我，我坐了反方向的电车。结果还是快11点才到家。&lt;/p&gt;

&lt;p&gt;科技的博客好久没有更新。一方面是前阵子手术，没时间；一方面是，日式外包，也就是这副模样。
好多30-50岁的前辈们，留给家的任务就是窝着床，睡觉。
按照他们上班的时间来算，他们回家之后的晚饭时间都很紧凑。
这个样子，也是一生。
这也是我最早不选择日本企业的原因——进了之后一定会外包出去，然后自己成为负责人。
好吧。虽然我依旧是在日本。&lt;/p&gt;

&lt;p&gt;开了这个个人站点之后就不敢这样子的吐槽了。总怕被抓包。
不过我发现，一旦限制了我的嘴，我竟然就什么也写不出来了。
那就这样好了。只要不影响我的正常生活。我就依旧如同在lofter一样吐槽就好了。
那就这样好了。&lt;/p&gt;

&lt;p&gt;记于2017 Nov.22 于东京&lt;/p&gt;</content><author><name></name></author><category term="essay" /><summary type="html">哇。写到一半。在notepad++上写到一半然后电脑就崩溃了。吓得我和我的小伙伴们都惊呆了。 竟然连备份都没有。 没办法，这个五年多的电脑变得越来越不安定。 可能是我之前安装cpu风扇的时候，那个散热的胶让我不小心涂在了边缘。 可能是我之前拆cpu的时候，不小心撞坏了顶针。 总之我也不知道是什么样的鬼原因吧。我是想换一台电脑了–起码换个cpu。 但是鉴于同等配置的笔记本的高昂价格。我决定依旧台式。 今天7点就下班了。竟然只加班了半个小时。我也觉得挺不可思议的。 我还以为大家都忘记了正常的下班时间（当然我总是忘记正常的上班时间）， 这次竟然没有在下班时间之后再给我安排任务。 我微微一笑。忍着头痛，踏上了回家的旅程。 头痛不负我，我坐了反方向的电车。结果还是快11点才到家。 科技的博客好久没有更新。一方面是前阵子手术，没时间；一方面是，日式外包，也就是这副模样。 好多30-50岁的前辈们，留给家的任务就是窝着床，睡觉。 按照他们上班的时间来算，他们回家之后的晚饭时间都很紧凑。 这个样子，也是一生。 这也是我最早不选择日本企业的原因——进了之后一定会外包出去，然后自己成为负责人。 好吧。虽然我依旧是在日本。 开了这个个人站点之后就不敢这样子的吐槽了。总怕被抓包。 不过我发现，一旦限制了我的嘴，我竟然就什么也写不出来了。 那就这样好了。只要不影响我的正常生活。我就依旧如同在lofter一样吐槽就好了。 那就这样好了。 记于2017 Nov.22 于东京</summary></entry><entry><title type="html">lofter迁移许久</title><link href="http://localhost:4000/blog/essay_blog/essay/2017/11/20/about-here.html" rel="alternate" type="text/html" title="lofter迁移许久" /><published>2017-11-20T00:00:00+09:00</published><updated>2017-11-20T00:00:00+09:00</updated><id>http://localhost:4000/blog/essay_blog/essay/2017/11/20/about-here</id><content type="html" xml:base="http://localhost:4000/blog/essay_blog/essay/2017/11/20/about-here.html">&lt;p&gt;从lofter迁移到这里。
却这么久都不更新文字。
可以推脱说，是生活不安定。心情跌落到了谷底。
毕竟，我连手写的日记都已经好久没有再写过了。
但是我不得不承认一个事实，就是。
很显然我这个日志的更新机制做的还不行。&lt;/p&gt;

&lt;p&gt;做了个小template。以后再写一个batch。把一股脑的动作都自动做了。
这样节约了麻烦，应该也就会更新的勤奋一些了吧（大概）。&lt;/p&gt;

&lt;p&gt;毕业有一阵子了。
对日本这个多重外包也有新的认识。
碰到一个做了快20年的前辈。下班了我要走。
他反问我。你回家这么早做什么呀。
然后他默默加班了2个小时。虽然没有什么任务。&lt;/p&gt;

&lt;p&gt;想起了知乎上的好多好多的言论。
懒得去辩解什么。反正，也正好到了该撤退的时候了，不是么。
做什么，都不要忘记了初心，不是么。&lt;/p&gt;

&lt;p&gt;研究室在举办OBOG会。同学找到我。我回说很想去啊。
然后我就没了下文。
我是真的很想回去。虽然里面没有国人。但是跟这几个人很想见一见，叙叙旧，讲讲今。
但是我现在的生活真的很不安定。我一开始就打算的回国。谁能想到会拖得这么久。
生活这东西你真的很难去判断去说什么。&lt;/p&gt;

&lt;p&gt;他就这么的来。&lt;/p&gt;

&lt;p&gt;他就这么的走。&lt;/p&gt;</content><author><name></name></author><category term="essay" /><category term="essay" /><summary type="html">从lofter迁移到这里。 却这么久都不更新文字。 可以推脱说，是生活不安定。心情跌落到了谷底。 毕竟，我连手写的日记都已经好久没有再写过了。 但是我不得不承认一个事实，就是。 很显然我这个日志的更新机制做的还不行。 做了个小template。以后再写一个batch。把一股脑的动作都自动做了。 这样节约了麻烦，应该也就会更新的勤奋一些了吧（大概）。 毕业有一阵子了。 对日本这个多重外包也有新的认识。 碰到一个做了快20年的前辈。下班了我要走。 他反问我。你回家这么早做什么呀。 然后他默默加班了2个小时。虽然没有什么任务。 想起了知乎上的好多好多的言论。 懒得去辩解什么。反正，也正好到了该撤退的时候了，不是么。 做什么，都不要忘记了初心，不是么。 研究室在举办OBOG会。同学找到我。我回说很想去啊。 然后我就没了下文。 我是真的很想回去。虽然里面没有国人。但是跟这几个人很想见一见，叙叙旧，讲讲今。 但是我现在的生活真的很不安定。我一开始就打算的回国。谁能想到会拖得这么久。 生活这东西你真的很难去判断去说什么。 他就这么的来。 他就这么的走。</summary></entry></feed>