<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <!--title> - Articles</title-->
    <title>Candy Water's Tech - Articles</title>
    <description>Welcome to Candy Water's world!!</description>
    <link>
    http://localhost:4000</link>
    
      
        
        <item>
          <title>关于一不小心就变成了图灵完全的...</title>
          
            <description>&lt;p&gt;最近几天没做leetcode的题，工作太忙了。明明就要离职了55555….
就顺便偷个懒，写点好玩的东西。主要内容和灵感来自&lt;a href=&quot;https://cpplover.blogspot.jp/2013/10/blog-post_20.html&quot;&gt;这篇文章(https://cpplover.blogspot.jp/2013/10/blog-post_20.html)&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1什么是图灵完全&quot;&gt;1.什么是图灵完全&lt;/h3&gt;

&lt;p&gt;首先我们要明确一个概念。什么算是图灵完全。
简单来说，就是跟万能图灵机具有同等计算能力的计算模型，就可以称之为图灵完全。
图灵机可以看作是当代计算机的简化模型。基本上图灵机就是抽象化的基本计算机模型。&lt;/p&gt;

&lt;p&gt;一般而言，大多数当代的编程语言都是图灵完全的语言。
跟NP的概念很类似，同样具有图灵机概念的话，理论上互相做的事情都可以相互转换。
也就是说，c++能做的到的大多数事情，js同样也可以做到。&lt;/p&gt;

&lt;p&gt;再譬如令人惊讶的brainfuck这门语言，也同样是图灵完全语言。那么理论上，可以用c来bind brainfuck，
brain来bind c就算了….c写的东西可以转换成brainfuck，brainfuck写的东西也可以转换成c。&lt;/p&gt;

&lt;p&gt;我目前知道的4种证明一种语言是图灵完全语言的方法：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.用这种语言实现重复处理。(也就是可以实现finite automaton)&lt;/li&gt;
  &lt;li&gt;2.用这种语言实现&lt;a href=&quot;https://en.wikipedia.org/wiki/Rule_110&quot;&gt;rule 110&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;3.用这种语言实现&lt;a href=&quot;https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life&quot;&gt;life&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;4.用某种语言制作可以另一种已经被证明是图灵完全的语言的complier来证明，这个语言是图灵完全。(这个可以说是不用证明)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INPUT -&amp;gt; PROCESS -&amp;gt; OUTPUT
          ↑___|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2不小心就变成图灵完全的&quot;&gt;2.不小心就变成图灵完全的…&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;c++ template&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/189172/c-templates-turing-complete&quot;&gt;[1]stackoverflow&lt;/a&gt;
  &lt;a href=&quot;https://www.artima.com/cppsource/codefeaturesP.html&quot;&gt;[2]用c++ template实现一些work&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTML5 + CSS&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/2497146/is-css-turing-complete&quot;&gt;[3]stackoverflow&lt;/a&gt;
  &lt;a href=&quot;http://eli.fox-epste.in/rule110-full.html&quot;&gt;[4]用css来实现的rule 110&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;万智牌(Magic: The Gathering)&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://www.toothycat.net/~hologram/Turing/HowItWorks.html&quot;&gt;[5]用magic牌实现turning machine的解说（我没细读…）&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Minecraft&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?feature=player_embedded&amp;amp;v=7sNge0Ywz-M&quot;&gt;[6]用minecraft实现的简易compute的油管视频，这里的ROM是人肉（视频作者…）&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;神奇宝贝 黄 （ポケットモンスター　イエロー）&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://tasvideos.org/2913S.html&quot;&gt;[7]利用黄的一个bug，可以改写游戏的memory addresses，从而进行图灵完全的实现（这个有点牵强….）&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Tex&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://hak7a3.hatenablog.com/entry/2016/12/17/122422&quot;&gt;[8]用实现一个图灵完全语言的编译器(complier)来证明这个语言是图灵完全语言&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SQL&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://assets.en.oreilly.com/1/event/27/High%20Performance%20SQL%20with%20PostgreSQL%20Presentation.pdf&quot;&gt;[9]sql的图灵完全说明&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(Cプリプロセッサー)&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://www.ioccc.org/years.html#2001&quot;&gt;[10]参照2001年的IOCCC大会的herrmann1条目&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;写完之后才发现其实要看的东西还蛮多的，很多基础概念要么就是忘记了，要么就是原本就搞得不太清楚….&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://cpplover.blogspot.jp/2013/10/blog-post_20.html&quot;&gt;うっかりチューリング完全になっちゃったもの&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://d.hatena.ne.jp/zrbabbler/20140607/1402135613&quot;&gt;TeX はどうしてアレなのか&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://hak7a3.hatenablog.com/entry/2016/12/17/122422&quot;&gt;もうひとつのTeXがチューリング完全であることの証明&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://0-chromosome.hatenablog.jp/entry/2015/12/07/000000&quot;&gt;TeXで簡単プログラミング♪&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ja.wikipedia.org/wiki/%E3%83%81%E3%83%A5%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0%E5%AE%8C%E5%85%A8&quot;&gt;wikipedia:チューリング完全&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Turing_completeness&quot;&gt;Turing completeness&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
          
          <pubDate>Fri, 23 Feb 2018 00:00:00 +0900</pubDate>
          <link>
          http://localhost:4000/tech_blog/tech/2018/02/23/somehow-becoming-tuning-complete.html</link>
          <guid isPermaLink="true">http://localhost:4000/tech_blog/tech/2018/02/23/somehow-becoming-tuning-complete.html</guid>
        </item>
        
      
    
      
        
        <item>
          <title>关于JAVA同期的初步学习笔记(2)</title>
          
            <description>&lt;p&gt;源于。。。。嗯。因为发现之前写过一个JAVA同期的东西。所以开了这个续集。&lt;/p&gt;

&lt;p&gt;前阵子做了一个cancel处理的一个小东西。好像是。。。组里的都嫌麻烦（？）反正最后玛德竟然抛给我了。
这是抛绣球么，净挑年轻的抛（？）我也很累的好么。&lt;/p&gt;

&lt;p&gt;简单来说是这么一个东西。
现有一个系统，是从browser端向DB传送数据。数据中途要经历大量的翻过来覆过去的转换类型，最后变成整整齐齐的一个个小表格塞到DB里面去。
ummmmm……..根据我的测试，server端的java里面的进程，大约是，100MB的数据，就会占据大约2GB的内存（RAM）。
本着不让server端迅速的因为大数据（咦？）而崩溃，目前已存的系统是这样设计的。&lt;/p&gt;

&lt;p&gt;允许一个账单的数据输入，不过是排队一个接着一个输入。
比如队列中有{a, b, c}三个文件，那么是按照顺序，先输入a，等a的处理结束之后从server端返回处理成功的response。等browser端接到response之后再开始b的处理。
同理c。&lt;/p&gt;

&lt;p&gt;使用方嫌等待时间太长了，要求出“取消”机能。这个很理解，我亲测，100MB的数据，我的小破电脑愣是跑了4-5个小时都没跑完。就算是workstation跑程序，就这个效率的话….
于是乎就跟文章开头一样，这个绣球最后就抛到我这里了= =||&lt;/p&gt;

&lt;p&gt;我考虑的有2点，
(1)不破坏现有结构。
(2)在现有结构基础上做到cancel处理。不留后遗症的cancel处理。&lt;/p&gt;

&lt;p&gt;我们可以把单个文件的处理过程大致分为5个过程。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;（1）从browser端发送数据之前的所有处理&lt;/li&gt;
  &lt;li&gt;（2）从browser端传送到server端的处理过程之中&lt;/li&gt;
  &lt;li&gt;（3）在server端进行数据的处理&lt;/li&gt;
  &lt;li&gt;（4）在server端数据处理结束之后，发送response之前&lt;/li&gt;
  &lt;li&gt;（5）browser端接受到response之前&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\stills\blog\20180214-java-sync-2\20180214-about-java-sync-2.png&quot; alt=&quot;process flow&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这里，（1）和（4）（5）基本是不用考虑的，在实际使用中需要考虑的是（2）~（3）。&lt;/p&gt;

&lt;p&gt;首先，这个处理是用xmlhttprequest来做的，那在传输数据的过程中，使用xhr自带的abort()可以取消（2）的处理过程。&lt;/p&gt;

&lt;p&gt;其次，要处理（3）的过程应当如何去做。tomcat是典型的多线程server，由于内部处理得当，所以处理数据的线程无法被其他的线程干扰。
也就是说，如果你发送一个cancel请求，事实上是无法直接遥控正在处理数据的线程的。
cancel处理可以使用thread自带的isInterrupted()这一属性，而想要遥控这个属性事实上也可以把这个thread的reference带走，譬如放到一个static的内部结构里面，
这样就可以用别的线程去遥控那个interrupted的属性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\stills\blog\20180214-java-sync-2\20180214-about-java-sync-2-2.png&quot; alt=&quot;cancel req&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果把thread的reference带出来也是可以。我们可以通过很多东西来确认一个独特的thread。比如sessionID + 现在的毫秒时间组成的独特的特征码。
这样的话我们把thread放到一个map里面就可以解决问题了。&lt;/p&gt;

&lt;p&gt;这里涉及到一个问题。如果不只是一个人在进行数据输入。不同进程同时处理一个static的map的话，会有小概率出问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\stills\blog\20180214-java-sync-2\20180214-about-java-sync-2-3.png&quot; alt=&quot;multithread cancel&quot; /&gt;&lt;/p&gt;

&lt;p&gt;经典的解决办法就是锁。在java里面是一个叫做synchronized的东西。简单而言，其实把整个method都上锁就可以轻易解决这一难题。（另一个据说很多JVM不按标准实装的volatile暂时不在讨论范围）
这里会涉及到一个效率问题。就是，如果锁的时间过长，会拖慢整个程序。如下面的参考资料，我事实上考虑过使用singleton的双重锁来解决不要static一开始就占用一块内存的地盘的效率问题。
不过在考虑诸多之后，因为原本想要锁住的操作也很简单，我就没有采用那种pattern。
我的做法是，cancel request来了之后，直接用上文的sessionID + 现在的毫秒时间组成的特征码来查看map中是否有thread的reference，有的话执行interrupt，没有的话直接放弃，不管cancel request的死活。
这样的话并不会出现锁住整个进程的问题。&lt;/p&gt;

&lt;p&gt;这样（3）也解决了。&lt;/p&gt;

&lt;p&gt;就这么愉快的解决了这个问题。说起来废话很多，也是因为一开始做了很多想法，比如储存cancel request，这样可以把cancel request的成败也通知browser端。
但是这样产生了别的问题，如果是恰巧在(4)和(5)之间的时候来的cancel request，就必须要把cancel request删除，不然会永久的留在内存之中。
这样的话要做一个可以定期自动删除数据的map…um……倒不是做不到XD 但是效率未免会太差了点。&lt;/p&gt;

&lt;p&gt;PS：
对了，记得知乎上的轮子哥曾经说过，如果只用getter，就不用同期锁。如果只要有一个进程要用setter，那就要做同期锁，而且要getter和setter同时上锁。&lt;/p&gt;

&lt;p&gt;仔细想想很有道理，不然如果只setter上锁，getter不上锁，在get的瞬间，数据还没得到的时候，但是代码已经执行结束的瞬间，如果被setter换了数据，那么就会得到不一样的数据。这样怎么想都有点风险。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://tomcat.apache.org/tomcat-8.0-doc/&quot;&gt;tomcat 8 reference&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/30721261/java-threads-and-thread-interrupts&quot;&gt;Java threads and thread interrupts&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.yuku-t.com/entry/20110225/1298567486&quot;&gt;JavaでSingletonパターンを実装するのにclassとenumのどちらを使うべきか&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qiita.com/neko_the_shadow/items/1879e8a8e6aec0e86845&quot;&gt;enumを利用したSingleton実装のサンプルコード&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/31409982/java-best-practice-class-with-only-static-methods/31410051&quot;&gt;Java best practice: Class with only static methods&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons&quot;&gt;What is so bad about singletons?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4074154/when-should-the-singleton-pattern-not-be-used-besides-the-obvious&quot;&gt;When should the Singleton pattern NOT be used?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;没太大关联的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/14223150/mapping-a-specific-servlet-to-be-the-default-servlet-in-tomcat/14225540&quot;&gt;Mapping a specific servlet to be the default servlet in Tomcat&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://d.hatena.ne.jp/daisuke-m/20100414/1271228333&quot;&gt;[Java]難解なSerializableという仕様について俺が知っていること、というか俺の理解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
          
          <pubDate>Wed, 14 Feb 2018 00:00:00 +0900</pubDate>
          <link>
          http://localhost:4000/tech_blog/tech/2018/02/14/about-java-sync.html</link>
          <guid isPermaLink="true">http://localhost:4000/tech_blog/tech/2018/02/14/about-java-sync.html</guid>
        </item>
        
      
    
      
        
        <item>
          <title>什么是pointer</title>
          
            <description>&lt;p&gt;写同期之前，写一个基础小知识吧。一个小学弟（初学者）问我什么是指针。
ummmm…….
这要用手机打字的话，估计会写到自己崩溃吧XD 恰巧身边有电脑，就记录一下。顺便把这个文章给他分享下XD&lt;/p&gt;

&lt;p&gt;pointer我记得汉语翻译是指针，一般是c和c++中特有的一个概念。不过php中也有类似于指针的东西，至于具体名字是不是指针我就不清楚了。&lt;/p&gt;

&lt;p&gt;想要理解指针，首先要理解的一个事情就是，内存(RAM)的作用。暂且抛却heap和stack的区别。我们在程序中所书写的所有变量(variable),函数(function)都是存储在内存之中的。
为什么存储在内存中？当然是速度快啊！当然你也可以在硬盘中一点一点读取，边用边读，当然这就是另一个话题了。
因为所有的数据都存储在RAM之中，
所以我们使用数据的进行计算的时候，也对应的要从内存中选择。
我学弟学习的是c++，我就用c++举例子好了。（不然我想用js的说TAT）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int a = 0;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里的a就是指向内存中的一块被宣言成为int的一小块区域。大小是根据你系统的bit数而决定的，64bit还是32bit的话，大小也会不一样。
当然，除了基本类型，譬如stl库中的类型，也同样是被存储在内存中的。就比如下面的v就是例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;int&amp;gt; v;
v.push_back(233);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是在传递数值的时候会产生一个问题。在譬如js，或者java一类的所谓的高等语言中，一般是会不让编程者注意到这一信息。事实上这一信息会产生一定的速度差异和优势，当然也会产生相应的编程困扰。
废话讲的有点多。暂且抛弃c++中的参照(reference)的概念，用pointer写一个简单的例子。
继续我们的基础类型int的例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int a = 233;
int* b = &amp;amp;a;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意我们的宣言，是int&lt;em&gt;，我们的类型是int&lt;/em&gt;。当然你写成&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int *b = &amp;amp;a;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;也是没有任何的错误的。&lt;/p&gt;

&lt;p&gt;这时，这个int*类型的b就是一个pointer。他指向的是a。
什么意思呢。原本我们的a，就指向的是RAM中的一个宣言为int类型的一个小空间。如果我们&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int c = a;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;那么我们所做的，是在RAM中再确立了另一块小空间，用c来指向那里，然后把a的数值copy过去。&lt;/p&gt;

&lt;p&gt;但是我们int*类型的b所做的，就是直接指向了a的空间。&lt;/p&gt;

&lt;p&gt;事实上不必怀疑，int*类型本身也是会占据一定的RAM空间的，当然这是后话。&lt;/p&gt;

&lt;p&gt;那么这样做会带来一个问题。就是，如果a的数值变了的话，会怎么样。
答案很简单。因为a的数值变了的话，a在RAM空间的数值会变化，所以b的数值也会变。但是c因为是在RAM空间的另一块区域开启的新空间，所以，a的空间变的怎样，其实是没有任何关系的。
所以即便a的数值产生了变化，c的数值也不会变。&lt;/p&gt;

&lt;p&gt;这就是pointer和普通变量(variable)的区别。pointer赋予我们的是直接操作RAM的能力。当然会有少许的性能代价(pointer本身也会占据内存)。也会有相当程度的风险，比如memory leak。
（爱，老哥我毕业论文就差点因为不小心写出了memory leak没法用程序验证理论，险些GG。多亏了valgrind这个神程序。。。。）&lt;/p&gt;

&lt;p&gt;当然，c和c++语言中的pointer，当然是不仅仅只有这个功能，还跟array有着密不可分的关系，所以说c写起来才让人头疼啊。。。。&lt;/p&gt;

&lt;p&gt;PS：这个array的汉语翻译我没找到。。。
这个等我今天晚上回家再继续码字吧！&lt;/p&gt;

&lt;p&gt;参考资料：
暂无。&lt;/p&gt;
</description>
          
          <pubDate>Tue, 13 Feb 2018 00:00:00 +0900</pubDate>
          <link>
          http://localhost:4000/tech_blog/tech/2018/02/13/what-is-a-pointer.html</link>
          <guid isPermaLink="true">http://localhost:4000/tech_blog/tech/2018/02/13/what-is-a-pointer.html</guid>
        </item>
        
      
    
      
    
      
        
        <item>
          <title>记录网站重构为nginx</title>
          
            <description>&lt;p&gt;近几天打算续写java的同期。因为做了一个cancel的多线程的东西，有了些许心得故续写。&lt;/p&gt;

&lt;p&gt;最早写tech博客是为了炫耀技巧。但是每次执笔的时候都发现，自己真是太菜了= = 没啥子好写的。每次都查着资料，查着查着就跑去打游戏去了&lt;span&gt;（喂！ヽ(●-`Д´-)ノ）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;但是现在发现，自己好菜，记不住自己曾经写过的东西= =。。。&lt;/p&gt;

&lt;p&gt;当然，我也知道这是人之常情，twitter上有个话题，就是各大出名library的作者，各种讨论自己花样记不住自己写的API的事情。编程中也有一个说法，叫做programmer永远记不住自己一个月以前写过的东西。&lt;/p&gt;

&lt;p&gt;由于。。。自己真的记不太住自己之前是如何用apache2来构建的网站（注释基本没有留。。。）所以这次只是简单记录如何简单的构筑nginx网站。
而且以后，&lt;strong&gt;也专心的记录自己写过的东西，防止忘了！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.首先，由于apache2正在运行，要先关闭掉apache2。&lt;/p&gt;

&lt;p&gt;不然，安装nginx之后，会自动开始运行nginx的service。之后会出错，导致你无法正确安装程序。但是可以删除程序！
可以先去验证是不是安装包出错了，再可以验证是不是sudo权限被占用。都不是的话，那就是apache的锅，（当然也可能是其他问题）关掉apache的service，重启nginx。就可以解决。&lt;/p&gt;

&lt;p&gt;2.nginx的configure&lt;/p&gt;

&lt;p&gt;apache的历史包袱很重，没有对比就没有伤害，nginx的conf文件，完全是类JSON形式的，只不过区别是尾巴一定要加上“；”。估计是为了方便complier处理以及为了可以缩写成一行吧。
JSON形式真的太好写了，而且非常易懂。&lt;/p&gt;

&lt;p&gt;举个例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http{
  server{
    listen 80;
    server_name candy-water.com;
    location / {
      root /abc/def;
    }
    error_page 406 /404.html;
  }

  if($scheme ！= &quot;https&quot;){
    return 301 https://$host$request_uri;
  } # 这里是cerbot帮忙写的
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;基本上已经不需要解释了= =&lt;/p&gt;

&lt;p&gt;本来多个virtual domain，我还打算找网上的资料。。。但是这一看就懂了。。。
我就多写了几个server，把server_name换了一下。。。。就成了。
不像apache，要写好多个小文件0.0  当然不写小文件应该也是可以做到的。&lt;/p&gt;

&lt;p&gt;后来查了一下资料。location所代表的意思是，类似于java servlet里面的url pattern，可以把url读取，然后转换为｛｝里面包裹的地址返回。
下次可以做个fast cgi试试。
我有尝试把http2放进去，不过我发现即便没有放，firefox会自动发送http2的get request（通过检查f12的network）。
所以事实上不放也是可以的。下次再仔细研究一下。
基本构建就是如此了，&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://qiita.com/Aruneko/items/8c11f9e45a33457c3c1f&quot;&gt;NginxでHTTP2を有効にする&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://nginx.org/en/docs/beginners_guide.html&quot;&gt;Nginx Beginner’s Guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://certbot.eff.org/#ubuntutyakkety-nginx&quot;&gt;cert-bot-nginx&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qiita.com/katzueno/items/44e02db2f1bfa0de5860&quot;&gt;nginx コマンド超シンプル早見表&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cyberciti.biz/faq/star-stop-restart-apache2-webserver/&quot;&gt;Start / Stop and Restart Apache 2 Web Server Command&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.skyarch.net/blog/?p=7088&quot;&gt;nginxのrewriteを使ったリダイレクト&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qiita.com/ryounagaoka/items/fd641e39a196b47db875&quot;&gt;Nginxのエラーページをカスタマイズする方法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://heartbeats.jp/hbblog/2012/04/nginx05.html&quot;&gt;nginx連載5回目: nginxの設定、その3 - locationディレクティブ&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-set-up-nginx-server-blocks-virtual-hosts-on-ubuntu-14-04-lts&quot;&gt;How To Set Up Nginx Server Blocks (Virtual Hosts) on Ubuntu 14.04 LTS &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
          
          <pubDate>Sun, 28 Jan 2018 00:00:00 +0900</pubDate>
          <link>
          http://localhost:4000/tech_blog/tech/2018/01/28/update-site.html</link>
          <guid isPermaLink="true">http://localhost:4000/tech_blog/tech/2018/01/28/update-site.html</guid>
        </item>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
        <item>
          <title>关于ACCESS的null的一个小问题</title>
          
            <description>&lt;p&gt;近来在用MS的ACCESS这个小型数据库来做一些抽取数据，以及验证数据的东西。
ACCESS可谓是麻雀虽小，五脏俱全的终极典型。
总会在你想不到的地方使用简单的鼠标点点点来完成一个又一个操作。
虽然还不大会怎么从外部的api调用access（对于现在的我也没有必要），
做着一个又一个小query还挺来瘾的——虽然这么说吧，我更喜欢编程。&lt;/p&gt;

&lt;p&gt;在传统的这种SQL式的database之中，关于null的设定就如同schema的设定一样，
在不同的软件中有着不同的设定。譬如在这篇日文&lt;a href=&quot;https://www.ashisuto.co.jp/corporate/column/technical-column/detail/1197236_2274.html&quot;&gt;博文&lt;/a&gt;中有总结，oracle的话会把NULL和长度为0的文字（也就是空文字）作为同等的东西去处理。
但是mysql就会把他俩当成不一样的东西处理。
提到schema就不得不提一嘴，我到现在也没弄明白它的具体定义，
好吧，我觉得以后有时间有兴趣的话读一读oracle的文档。&lt;/p&gt;

&lt;p&gt;那么在ACCESS中是如何处理的。这里有份&lt;a href=&quot;https://support.microsoft.com/ja-jp/help/883247&quot;&gt;微软的日文文档&lt;/a&gt;。
里面详细的讲到在ACCESS中，null和空文字是两个概念。不过用Is Null和Not Like “*“，抽出的结果是相同的。
也就是虽然是2个概念，但是可以用同样的statement来抽出。&lt;/p&gt;

&lt;p&gt;这里总结一下定义的不同。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;null属于空文字or数值不确定的数值。&lt;/li&gt;
  &lt;li&gt;空文字只是空文字而已。可以用这个来输入“”。有的table不支持输入“”。那你就改table的设定，强行输入空文字。&lt;/li&gt;
  &lt;li&gt;根据table的设定不同，你可以用enter等来输入空文字，也可以不支持输入空文字。&lt;/li&gt;
  &lt;li&gt;用Like “*“的话，可以抽出空文字&lt;/li&gt;
  &lt;li&gt;用Not Like “*“的话，不可以抽出空文字，只能抽出null&lt;/li&gt;
  &lt;li&gt;用is Null 的话，不可以抽出空文字，只能抽出null&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;好吧。这篇文章介绍怎么更改设定，然后输入空文字。有一个很详尽的表格介绍。&lt;/p&gt;

&lt;p&gt;我来讲讲的我遇到的问题。
从外部的sql系列的数据库抽数据。
然后有一行的record，是空数据。
然而我们需要进行外部结合，把这个数据表格，和我们已有的数据表格比较。
然后把重复的去掉，把我们已有数据表格里面不重复的留下。&lt;/p&gt;

&lt;p&gt;好吧，我想说，空白数据的很烦（在不更改两个数据表格的前提下）。劳资先把空白数据都用select先去掉再说。
神奇的事情发生了。
我使用&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;is not null and &amp;lt;&amp;gt; &quot;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;结果愣是抽不出来。。。。&lt;/p&gt;

&lt;p&gt;后来还是我的大叔给出了解决方案。他边把思路说给我听，我边写着代码。
先进行值的判断，看是不是null。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iif( IsNull(A), &quot;&quot;, A)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后在条件那里&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;&amp;gt; &quot;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;先把null的都转换，然后再跟空文字比较。
解决！&lt;/p&gt;

&lt;p&gt;厉害了我的大叔。我的天。&lt;/p&gt;

&lt;h3 id=&quot;事后反思&quot;&gt;事后反思：&lt;/h3&gt;
&lt;p&gt;当然仔细的想一想。is not null可以抽出空文字，不可以抽出null。
&amp;lt;&amp;gt;”” （大概）可以抽出null，不可以抽出空文字。&lt;/p&gt;

&lt;p&gt;那么也就是说，我们假设2个数据库表格中，分别存在null和空文字。
那么&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;抽出null的时候。
是用&amp;lt;&amp;gt;”“抽出来的，然后和不可以抽出null的is not null的AND条件发生激烈碰撞。
结果就是不符合条件抽不出来。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;抽出空文字的时候，同样是两个条件互相搏击打架，结果就是导致无法满足抽出条件——弄巧成拙。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大叔讲的话很简单。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;涉及到null就很烦啊，我也不知道具体是啥意思，
我就记得sql server的时候null的处理就很花心思。你用if文大概这么做一下吧。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;道理很简单，这东西可以用简单的方式绕开的话（而且不是很降低效率到不可以接受的程度的话），
那就绕开它。专心做逻辑。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ja.wikipedia.org/wiki/%E3%82%B9%E3%82%AD%E3%83%BC%E3%83%9E_(%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9)&quot;&gt;スキーマ_(データベース)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/cd/E12151_01/doc.150/e12155/oracle_mysql_compared.htm#i1026408&quot;&gt;Oracle and MySQL Compared:2.2.3.2 Column Default Value&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ashisuto.co.jp/corporate/column/technical-column/detail/1197236_2274.html&quot;&gt;SQLの観点から「Oracle Database」「PostgreSQL」「MySQL」の特徴を整理しよう！&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://support.microsoft.com/ja-jp/help/883247&quot;&gt;Access の Null 値と、長さ 0 の文字列の違いについて&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
          
          <pubDate>Wed, 30 Aug 2017 00:00:00 +0900</pubDate>
          <link>
          http://localhost:4000/tech_blog/tech/2017/08/30/access.html</link>
          <guid isPermaLink="true">http://localhost:4000/tech_blog/tech/2017/08/30/access.html</guid>
        </item>
        
      
    
      
        
        <item>
          <title>记，升级到https的菜鸟旅程</title>
          
            <description>&lt;p&gt;起因之一是看到月光博客的&lt;a href=&quot;https://weibo.com/1494759712/FizDQd6sQ&quot;&gt;微博&lt;/a&gt;，&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;据谷歌邮件通知，从2017年10月起，当用户在HTTP网页上的表单中输入文本时，Chrome（版本62）将显示一条“不安全”警告，并在所有无痕模式下的HTTP网页上显示这一警告，即使没有密码也会显示警告，解决方法是：迁移到https。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;恰巧同时期看到twitter上有人谈及&lt;a href=&quot;https://letsencrypt.org/&quot;&gt;let’s encrypt&lt;/a&gt;。
本来还打算用aws的一些服务或者找一些别的CA去花钱挂一个证书，但是看到这个好像不错，就从文档读起。&lt;/p&gt;

&lt;p&gt;事实上文档写的很简单，大致就是&lt;a href=&quot;https://letsencrypt.org/getting-started/&quot;&gt;你要有一个cgi的环境&lt;/a&gt;，
然后我们用&lt;a href=&quot;https://certbot.eff.org/&quot;&gt;certbot&lt;/a&gt;就可以非常简单嗨皮的构建https环境。
很傻瓜。但是事实上如果用apache一类的，也不过是装个mod，然后把证书的path写上去，同样是傻瓜式的构筑，而且是很麻烦的那种傻瓜。
既然这样，倒不如用let’s encrypt这种看起来就很赞，而且目标和梦想都很伟大的project – &lt;a href=&quot;https://en.wikipedia.org/wiki/Let%27s_Encrypt#Overview&quot;&gt;要加密整个互联网，啊哈。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;文档虽然简单，但是介绍了它的一些特性，比如支持什么样的算法（但是这里我找的不是很清楚，看的不太仔细，只是看到略提一笔）。
还说好像是60天就会一自动更新。而且还提供了譬如不使用sudo的一个certbot的fork。&lt;/p&gt;

&lt;p&gt;看起来这么赞，
就照着它的使用说明用吧！
虽然我原本是想使用最复杂的椭圆密码和椭圆验证。
但是秉着&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;先有一个，再要好的一个&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;的这样一个基本原则，我按照操作说明很简单的操作起来。
&lt;a href=&quot;https://certbot.eff.org/&quot;&gt;操作说明:https://certbot.eff.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;可是结果大大出乎我的意料，明明应该很简单就可以构筑的东西为什么会来来回回的失败。
（我怀疑是我的参数设定错误所以一直更改原本网站的参数然后继续尝试）
失败到后来我竟然被let’s encrypt CA 禁止了一段时间去认证 – 失败的认证次数过多，相当于被“禁言”了几十分钟。&lt;/p&gt;

&lt;p&gt;我把mariaDB和mysql的残骸清除，把过去装的一个垃圾傻瓜邮箱伺服器系统的残骸找到清除，
（那个“开源”邮箱伺服器系统竟然不提供卸载功能，作者留言说，要想卸载，重装OS吧。简直是WTF，作者还是国人，丢。。。。）
到最后才发现根本原因，我的virtual host的设定导致他无法正确的打开443port。。。。。因为我设置是伺服器从本地（伺服器）出发只能走80通道。。。。。
（当初是多神经才这么设定，一定是设定错了。。。。当时考虑的可能是防御hacking？？？！我应该是把目的地和出发地设置反了）&lt;/p&gt;

&lt;p&gt;然后无奈的暂时取消掉virtual host，装成功了之后再一点点设置回来。
还好certbot还比较聪明（写的比较傻瓜）&lt;/p&gt;

&lt;p&gt;看，&lt;a href=&quot;http://candy-water.com&quot;&gt;candy-water.com&lt;/a&gt;，无论怎么走，都是从443通道了，真开心！&lt;/p&gt;

&lt;p&gt;参阅资料：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;let’s encrypt:&lt;a href=&quot;https://letsencrypt.org/&quot;&gt;https://letsencrypt.org/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;certbot:&lt;a href=&quot;https://certbot.eff.org/&quot;&gt;https://certbot.eff.org/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;部分document:&lt;a href=&quot;https://certbot.eff.org/docs/&quot;&gt;https://certbot.eff.org/docs/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;劳资要加密全世界的宣言:&lt;a href=&quot;https://en.wikipedia.org/wiki/Let%27s_Encrypt#Overview&quot;&gt;https://en.wikipedia.org/wiki/Let%27s_Encrypt#Overview&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
          
          <pubDate>Sun, 20 Aug 2017 00:00:00 +0900</pubDate>
          <link>
          http://localhost:4000/tech_blog/tech/2017/08/20/abouthttps.html</link>
          <guid isPermaLink="true">http://localhost:4000/tech_blog/tech/2017/08/20/abouthttps.html</guid>
        </item>
        
      
    
      
        
        <item>
          <title>关于rust的初步学习笔记(1)-heap和stack的基本概念</title>
          
            <description>&lt;p&gt;因为个人对java并没有什么热爱，
（然而我的c++书籍的阅读却没有我小说的阅读进度快…)
加之近来身体不佳。
关于java同期的探索暂且告一段落———反正这个知识早晚会再次用到。（那时再来探索吧）
虽然我应该近期会优先探索非同期的部分——nodejs的部分。&lt;/p&gt;

&lt;h2 id=&quot;关于rust&quot;&gt;关于rust&lt;/h2&gt;
&lt;p&gt;缘由是在知乎上偶然看到这个东西。我错把这个东西当成的c++的一个衍生物品。以为是类似于RAII一类的东西。
事实上随手查阅这个东西的时候，才发现是一门语言。
而且是Mozilla主导开发的。一下子好感度大增，撇下只是看维基百科没有看的太明白的RAII，读起了rust的document。&lt;/p&gt;

&lt;p&gt;rust的document很完备。
我这里就权当一个读书笔记了。&lt;/p&gt;

&lt;h2 id=&quot;heap和stack&quot;&gt;heap和stack&lt;/h2&gt;

&lt;h3 id=&quot;为什么讨论heap和stack&quot;&gt;为什么讨论heap和stack？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;rust的文档中提到了他俩&lt;/li&gt;
  &lt;li&gt;事实上语言在内存中运用的时候，有时候会考虑到这两个数据结构。因为这是计算机内部的系统结构的一部分。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基础概念&quot;&gt;基础概念&lt;/h3&gt;

&lt;p&gt;关于algorithm上heap和stack是怎么一个定义这里就不多赘述了。因为stack的结构简单，所以 理论上stack会比heap要快。
在acm中heap常会被用一个array来实装，而stack由于一般大多的stl都会提供实装，所以并不需要手动实装。&lt;/p&gt;

&lt;p&gt;这里需要说一个点就是，&lt;a href=&quot;https://ja.wikipedia.org/wiki/%E3%83%92%E3%83%BC%E3%83%97&quot;&gt;日文维基百科&lt;/a&gt;中会说到heap的删除时间是O(log(n))。
这个给我绕住了。
因为我印象中，比如容纳{4, 5, 6}的一个heap的话，指定删除一个值6，事实上不可能是log(n)。
然后我看到了搜索一个值需要的时间是O(n)，我迷惑了，怎么搜索的时间会比删除的时间要长。
然后我意识到，容纳{4, 5, 6}的一个heap的话，删除一个值是说，删除一个指定index值的值。
相当于删除index是0 or 1 or 2 的一个值。这样的话删除时间的确是O(log(n))。&lt;/p&gt;

&lt;p&gt;(PS:英文和中文维基百科就讲的很清楚：“delete-max [or delete-min]”)&lt;/p&gt;

&lt;p&gt;绕开heap和stack这些繁复的algorithm的基础定义。
我们来看rust中是如何定义内存中heap和stack的使用的。&lt;/p&gt;

&lt;!--
&gt;For data with a size unknown to us at compile time or a size that might change, we can store data on the heap instead. The heap is less organized: when we put data on the heap, we ask for some amount of space. The operating system finds an empty spot somewhere in the heap that is big enough, marks it as being in use, and returns to us a pointer to that location. This process is called allocating on the heap, and sometimes we abbreviate the phrase as just “allocating.” Pushing values onto the stack is not considered allocating. Because the pointer is a known, fixed size, we can store the pointer on the stack, but when we want the actual data, we have to follow the pointer.
--&gt;
&lt;blockquote&gt;
  &lt;p&gt;The heap, on the other hand, is slower, and is explicitly allocated by your program. But it’s effectively unlimited in size, and is globally accessible.
– rust first-edition document 4.1. The Stack and the Heap&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Accessing data in the heap is slower than accessing data on the stack because we have to follow a pointer to get there. Contemporary processors are faster if they jump around less in memory.
When our code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function’s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;– rust second-edition document 4.1. What is Ownership?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就是说，&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在内存中，stack是被你的rust确保的，而heap是被你写的程序所确保的。&lt;/li&gt;
  &lt;li&gt;确保空间大小的时候，stack是必须是固定大小。heap是pointer式的指向，所以不用固定大小。&lt;/li&gt;
  &lt;li&gt;heap往往是全局类的（global）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;关于stack&quot;&gt;关于stack&lt;/h3&gt;

&lt;p&gt;再详细的讲。
在呼叫一个函数（function）的时候。函数的一部分情报，以及函数内部的定义的局部变量，会被记忆到stack中。
这也是在acm中，使用递推（Recursion ）来解决一些问题的时候，由于呼叫自己的次数过多，导致内存不够用，
产生著名的stack over flow问题。（这里并不是在说同名问答论坛）&lt;/p&gt;

&lt;p&gt;这样的stack空间，在这个函数结束的时候，会被解放。
也就是说，哪怕你的这个函数内部定义了1GB大小的非pointer式指向的array，
但是是被线性呼叫的，而不是被同时呼叫。
那么在4GB的内存上理论上也是没有问题的。&lt;/p&gt;

&lt;h3 id=&quot;关于heap&quot;&gt;关于heap&lt;/h3&gt;

&lt;p&gt;也就是说，在函数内部呼叫例如&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;的一行的时候，这里使用的就是heap。&lt;/p&gt;

&lt;p&gt;使用heap的时候需要注意产生的一个问题就是，由于属于pointer指向，会产生这个内存领域没有被解放的问题。&lt;/p&gt;

&lt;p&gt;比如，函数内部呼叫上面的一行指令的时候，会在stack（根据rust的document）生成一个pointer，指向heap领域。
在函数结束的时候，这个pointer会跟着一起被毁灭。但是所指向的heap领域在有时候并不会被毁灭。
在c++中，大部分stl（可能是所有的？）在函数结束的时候都会自动运行destructor（如果我没有记错）。
来进行内存的解放。
然而过分的解除和确保heap领域可能会造成fragmentation问题
（？）（参见&lt;a href=&quot;https://www.uquest.co.jp/embedded/learning/lecture16.html&quot;&gt;ヒープとスタック&lt;/a&gt;
这里就已经是硬件方面的编程了，属于我不懂的领域）&lt;/p&gt;

&lt;p&gt;rust是如何处理这一问题的呢？&lt;/p&gt;

&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;这里我有一个疑问，那么全局变量呢（global variables)呢？如果是array或者int的话？
是属于stack还是heap？
答案是在c中，这是使用了另一个叫做data segment的区域。（参见&lt;a href=&quot;http://www1.cts.ne.jp/~clab/hsample/Point/Point19.html&quot;&gt;関数や変数のメモリ配置&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;那么rust是如何处理这些繁复的内容的呢？
这些疑问留给下次吧，我累了= =&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;第一版rust的document：&lt;a href=&quot;https://doc.rust-lang.org/book/first-edition/&quot;&gt;https://doc.rust-lang.org/book/first-edition/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;第二版rust的document：&lt;a href=&quot;https://doc.rust-lang.org/book/second-edition/&quot;&gt;https://doc.rust-lang.org/book/second-edition/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;ヒープとスタック：&lt;a href=&quot;https://www.uquest.co.jp/embedded/learning/lecture16.html&quot;&gt;https://www.uquest.co.jp/embedded/learning/lecture16.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;関数や変数のメモリ配置：&lt;a href=&quot;http://www1.cts.ne.jp/~clab/hsample/Point/Point19.html&quot;&gt;http://www1.cts.ne.jp/~clab/hsample/Point/Point19.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
          
          <pubDate>Sun, 20 Aug 2017 00:00:00 +0900</pubDate>
          <link>
          http://localhost:4000/tech_blog/tech/2017/08/20/about-rust-1.html</link>
          <guid isPermaLink="true">http://localhost:4000/tech_blog/tech/2017/08/20/about-rust-1.html</guid>
        </item>
        
      
    
      
    
      
    
      
    
      
    
      
        
        <item>
          <title>关于JAVA同期的初步学习笔记(1)</title>
          
            <description>&lt;p&gt;缘由是看知乎的一个&lt;a href=&quot;https://zhihu.com/question/29971746/answer/46320214&quot;&gt;答案&lt;/a&gt;,
里面写到同期的部分愣是没看懂.
由于我自己也没写过需要同期的东西.
就参照几个东西边看边研究.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.techscore.com/tech/Java/JavaSE/Thread/index/&quot;&gt;techscore マルチスレッドプログラミング&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/jp/java/library/j-jtp06197.html&quot;&gt;IBM doc Javaの理論と実践: volatile を扱う&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html&quot;&gt;oracle doc Synchronized Methods&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://d.hatena.ne.jp/Nagise/20111130/1322628285&quot;&gt;Threadの割り込みを活用する&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;关于sleep&quot;&gt;关于sleep()&lt;/h3&gt;

&lt;p&gt;首先是关于sleep(),根本就没搞清楚他是什么意思.
(完全没有搞懂它内部是如何实现的)
自己动手丰衣足食,自己来尝试一下吧.&lt;/p&gt;

&lt;p&gt;假设有A,B两个class.
同时call(1 step的时间差忽略不计)
因为sleep是static method.
那么我想知道,&lt;/p&gt;

&lt;p&gt;如果class A每2秒count一次,
class B每3秒count一次.&lt;/p&gt;

&lt;p&gt;那么是否会出现,&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;time(s)&lt;/th&gt;
      &lt;th&gt;output A&lt;/th&gt;
      &lt;th&gt;output B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;的情况.( “-“ 代表不输出数值)&lt;/p&gt;

&lt;h4 id=&quot;代码如下&quot;&gt;代码如下&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Main.java&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Main{

  public static void main(String args[]){
  TestThread a = new TestThread(&quot;class a&quot;, 2000);
  TestThread b = new TestThread(&quot;class b&quot;, 3000);

  a.start();
  b.start();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;TestThread.java&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
public class TestThread extends Thread {

  private String name;
  private long sleepTime;
  private long time;

  public TestThread (String name, long sleepTime){
    this.name = name;
    assert(sleepTime &amp;gt;= 0);
    this.sleepTime = sleepTime;
  }

  public void run(){
    this.time = System.currentTimeMillis();
    for (int i = 0; i &amp;lt; 3; ++i){
      try{
        sleep(sleepTime);
      }
      catch (InterruptedException e){
      }
      System.out.println(name + &quot; : &quot; + i +
        (System.currentTimeMillis() - time)/1000 + &quot;[s]&quot;);
    }
  }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;结果-测试环境wsl-win10-openjdk-8&quot;&gt;&lt;strong&gt;结果&lt;/strong&gt; (测试环境WSL, win10, openjdk-8)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%time java Main
class a : 02[s]
class b : 03[s]
class a : 14[s]
class b : 16[s]
class a : 26[s]
class b : 29[s]
java Main 0.11s user 0.22s system 3% cpu 9.315 total
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以说是出现了匪夷所思的结果.
因为只运行了9秒,但是currentTimeMillis()却显示运行了近30秒.&lt;/p&gt;

&lt;p&gt;虽然显示的数值并不符合预期,
但事实上在class A的第三次,class B的第二次输出,几乎是同步进行的.
(对for文的数值更改为6,并进行的多次测试,获得同样结果)
&lt;strong&gt;符合我的猜测&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;解决了sleep()的疑问,但是带来了&lt;strong&gt;新的问题&lt;/strong&gt;.
这里的currentTimeMillis()到底是怎样的机制?
如何才能正确的测量时间?&lt;/p&gt;

&lt;p&gt;下个探索的阅读材料集锦&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://d.hatena.ne.jp/sardine/20091226/p1&quot;&gt;Java: currentTimeMillis() と nanoTime() は混ぜると危険&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://d.hatena.ne.jp/higher_tomorrow/20100407/1270639866&quot;&gt;Javaアプリケーションのログの時刻がずれている&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;后记&quot;&gt;后记&lt;/h1&gt;
&lt;p&gt;我发现我犯了一个很低级的错误。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.out.println(name + &quot; : &quot; + i +
	(System.currentTimeMillis() - time)/1000 + &quot;[s]&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;中，第一行的行末没有添加空格，所以正确的output应该是，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class a : 0 2[s]
class b : 0 3[s]
class a : 1 4[s]
class b : 1 6[s]
class a : 2 6[s]
class b : 2 9[s]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;错误的不是程序，而是写output的我自己。&lt;/p&gt;
</description>
          
          <pubDate>Thu, 13 Jul 2017 00:00:00 +0900</pubDate>
          <link>
          http://localhost:4000/tech_blog/tech/2017/07/13/tech-java-sync.html</link>
          <guid isPermaLink="true">http://localhost:4000/tech_blog/tech/2017/07/13/tech-java-sync.html</guid>
        </item>
        
      
    
  </channel>
</rss>
